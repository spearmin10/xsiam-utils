commonfields:
  id: Scenario Log Player
  version: -1
vcShouldKeepItemLegacyProdMachine: false
name: Scenario Log Player
display: Scenario Log Player
category: Utilities
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAPHElEQVR42u2ceXRUVZ7HP++9SqWqUktC9oSsQIIEFAzocKKyxHZ30FF6DiCC58wRt27pafs0ztjoIOgwY9MuNDgz0qAj3T1jq62D7cC0JGwNNAgqBFkFIhBCtkrtlXrv3fmjHipYIVVJSOjI95w6VZX83u/Wq++9v/vbbkHfwwI8DGwCPIDoo4cONAN/AP4WkPgOoK9vciTw9qhRo8rmzp3LiBEjMJvNfTZ4IBBg165dzJ8/n/b29k0G0Q1cRq9gONCyaNEi4Xa7RX+ioaFBPPTQQwI4AKRdpqbnkIHdzzzzjIhEIuJSgNfrFTNnzhTA6sv09BzfLyoqEq2treJSwsGDB8/uzxWXKeoZ3lm+fLm4FDFnzhwBLBjIprMvUHnVVVddkl/AxIkTAcZdJrhnyHc4HJfkF5CRkQGQHuNfRcBQYAxQ2svDOgEFeNl4ffdfOsGKJF2aYafJZOrse3ACVqANSAbuB67rpWEfBjTgh4APOG0Q3vv3d9k96BR7znt/yCDaAoS6qbPYuHbxN/6mA1uBOwEV+PAvcQUPBKiAH3i8BzquM/TEwhqgJkF9jwJPXya4d/GvPbj2TaLp0lgQBvnTEtAXMgheSCdZyYtOcMbsBWlJFddxptVDY3Mbmq4nrEMIQVNrOydPN3GqsRmvP9ifBOtAVTeuMxtmuCsrsS8BnSuAp4B/AP45Fskx9+Dbn3p1Q4bLfo0u4NCppj1H3N4pTavmJ5SzzZy9YHJFZur8iuL8G2wTxrK+3sf7BzYTDoaYNHwwN4+/Eqc95cLTM9zBH7d9ytYjp/GpOnabFVXT8PgCFLks3FI5nNFXDOkPkouALQlek2SY+K6w1yBKxKn3OSBi7OtJwI+/eW1MglVdTxlZXmrRhSAUDo874vbef55jcEFM+snLz105tPDJsiFFtLS6UUwmFEnCbk8hyWRib6ufnf/1EQ/fcg3F+TkxdTS2tLH09xtJdqVistoYMigVnz+AYlJwOR0gwVu7vuCzQ8e5785JyH3rpf+6G9f4gfVxyN1qeNU7E9w2dONZBn50luSYBF9RnI/QdXRd4A11JHQXVX//iyeqrxn1pNNu53j9KawWM7v2HSYY7iDNkcLQglyyszI4o+v8x/99zIPfG0tRfvY5Ojy+AM+9+b/kFxWgmBTsNitbdn6GNxiOLp/cDMpLCgh3qDSKJN547yNm3XVjX5bGhhgh1N4ErpkE7ALau5DbZnjqieLnxkp+0VjJPwD0mHvwwfoGZEVBVhQcFnMiZnnYFYW5C2VFwR8M0ur1sWzdVjbW7WdaZTEPTh6NQw1y7ORpUl0OrHY7P3v9A7z+wDl63t2wk6KhpSgmEz5/kMW/W8eZphZmV43gybuu4+byfOqP1mOxJBMKR/jc3cH2Tz7vyxUcMuLYROAAAnHINQMnuvm5XjaIfQhYBsgxV3BhdjqqqqEJgT8ciVv7yKzUn5aXFiZLsozX6+f3uw8gwUutby15fOzTD1BRUcGka69i5fu1HPf5caTYyMnP5d0/buX+KdUANDS18skpN5npaciSxLo/76F68CBe+fFM0lxfZ8PGjDjDkg+2U1qQS4eqsvT9TYwdWYbJ1Cv5AjPR/HRvF6snJhAvH+vBOEeAOUAkJsEH6hsoKylAFwKnNTm+1TtrgTIkN2uqrmlokQg76w4hwQGB9ASIc2LHm64dyS/XfUxAkhjkcvDKR9u556YqUqwWdu49RHF+DpIs0eb2cKjVw68ee+AccgGK8rJIS4LDR+uJqBrrjjZypP4U5aUFvUGEC5jbRSIoEUeoO/I9wdndanLMGxhelEdEVdF0gcfY9+JQebXTkeJUTCaSJImjLe0A/9686mffCuzzszOI+H1kpKehRlRKswex/0g9lSPLONrqJygnIQQcO3Gau4blUl4yOOaQM6vHUvX0Cu4bVcSr0yd/axL0AE1AzgUIlgxn6A8J6JwKvNUH5OYA7wM2YFrMGzhxpoUhhXkgCWzmpHgVjxiU5kRVNbz+AE3RifFRZ8LDctNpCoaQFZn0VCeH6huoHFnGp/WNVJSVghC0+4NMu7a8c0+nIJf6f5uHOemiZFzdXfz/jQT1LU9A9hFjD00UucB/G+RWA3Uxnazi3CxUTUNVNXzh+LxokyRlK7KMyfB6jQRFp55PeooFm82KLMuYFIVjDc34g2HSnA5C4TChcAdHm90U5Hxd6NF1nY6Ies4DoCOiomoafYxE658TE5D9czc+T74RhrmAyUBdp2HSkROnKR6cgyxEIl60zaQoaJpGU3MrgL/59ac7nR1JJoVAewBFMZFkUmj1eNE0lUAwxODcLAQiOgmsX0cM763fztr9J9F1gSQBkkRHRwS7zYrm9/L0rDvIzuizFqurgU8TNJ3xYmeCn6XAsJY2g9wDF0x05GemoRtxcCiixjtIROgCk6KQGt0Lta7Sj1aLBU3T0HUddIEkyViSzUQiEQTgC3WgyOcamdKCXJAkTLJMIBzBYbPg8Qc47PGy6eO93Hvz9X1F8MoE5X+bgOx9RHvF4nHKig1yTUasfajLVOXxM60MLSlESGA2xbe/qUI0qUInEtHwBkIQLa11ihZfCG9Ix6QodKgaqWYTKVYLLR4/+blZCCA71fGVGQYwJ5nYc/AgEU1DAhRFYUhBLi6XE7UbOe4eYgywO05ZkyG/I075LxIgt+YbiZQvzheIuQcPzctCRiAJnVAk7jj4sKfdi9WcRF5WOrIkJWfOXtCpvTx2pg1Xig2zSaGt3UtehgtZlijPS0dTVbSIitNmod33dW7g9gnjuPfqIdxansct5Xm49A4yB7nwtHswyX1eGJuUYB66MAH5P8Up95iRooxJbqcEN7W1o8gyiqJgjd9D3eH2+FRd01FVlTE5g87uU99CW7uXADLhjg6EgBMtbkrysqKbidOCOSkJs9lEQU4mh46fW+OYUv1XzLr7RmbdfSNXDC3E7w/idKTQD1iSgGwQeDsB+SnEbiM6H0uJ1pg7TYrEJNjpsBOMqIQiKv6O+PbgplXzvada3GtVAToSw6MJhymxZDd/sh+b3Q6KgtvnZ3+Lh/KS/KjnUlZIk9uDP9SBxWpl7Z6jRNRvf4YWt4fdJ1sxmc20ef2ouuhrgosTkM0AShKQbzNWZlc4RhcnM2ISfKalDZvZhDXJhCM57jiYrcdPL/F4vKBr5GWkMXHI4AcyZy8454vYd/g4az47RrrTjh6JcPjol0wenE5JQW40yTKkECnox2G14LRZGFpaRM32c53ViKrym3XbKC8ZTDgYIDPNhdL3LV9TEwxhyhOQ32iQ3GPEtL+ZaU40XaDpOrlZ6dxhsz5n/eXbC9s8PmzWZHRNRwdMskxLu5ctxxpuaFo1f2vTqvnra9OWrL69qnKG1WJmzBVD7OmulN21wcep3XWQrYfPUNfooaykgEAohMfjo/bISf5n7r1flfsUWeb+6rH855Z9pDrtZKansvVEO5//9kNKc9JRNZ3d9U3YXKn4fQHc7nZyJJl+aOr7eQKye0is8jSUaBPegYtCcJsviKoLNAF5OZnk6EIORSJycUEe/nAH1iTTV16rtbEJjjW8AowFONTme/DDrbsLq8eNut5uT2FwXk7qjO/fi0eWELogOzsTfyiMu93Lm5t3M2/SlVxz5fBzxi8rGcxNre18UPclTocdWVEIJ6fxWWsHkixhdqWhCZ0tn3yO05pMfn5uf3jROURPR/rikC0znKB4szEhIO+ireBAMMSZM03oAhRJQheCiKbjS1IIRTSSTcpXrTdtbs/5e3FAzF5wa/hPu98ZUZBzU1FeFjabjSRFxhsI0e7xcuD4KXacbOKnE6/ksWm3x1x911dWIHSdpWt3MKwwj0gkgtOeQiAYornVzaeH64mEwlxbnE1baxvhBKpevYShRjrzszhkrwWOJqD7BN0vGXZN8K6G5nt2NbS8Q/zHS8/pI2peNd/P7H+69VjdF7Oo++JRoPJsKUWRJGaNLmHBtGqurhh2wQFuGDeK0oIc3v1oO6/W7qa5Q0UAybLED6+rYOadE7AlJzPr+ZWc8gTijtl7CRsTkH2DxCtJk+m6A2S5Yf6X0Z+QXDli45ZtorGlTQRD4W6dIYqommhqdYvG5u7riIWamhrRjdTgWcQb23bncNvfxCHzd4bZf7azxdgnU160n2aQy07WoNTumxpFJiPNxSWGmcCiOOT+GiP5nwDeiUPmNSPG/hWQTbQKpfY5wX0NTdOoq6vD57uw/yPLMvv27cNisfhCoW4dVlgUp9zz3dB9G7COzhvlz2I10Taft4BMYLpB+sAkWNd1Fi5cyIsvvkhVVdUFw6c1a9aQkpISGT9+/E9qamq6M1wyMB6ovYDMTQZRCc9TI34+HofsWqL13zXG6yln4+gBR/D+/ftZtmwZK1euJDW18y2hpqaGvXv3iurq6tkrVqzY0c3hVCNDdSGCc7upe22C8juA64l2mWwwLMCJAXd0xefzMWnSpAuSu379el566SVV07S7VqxY8eseDKcRLRt2VuvNBl7vYbZsnDFJzEbmUTrvGb4+mRgEJhjvNwOOAXk2SVE676zcuHEjS5cuFWPGjLn/yy+/fL+XhpxHtGJ0tkRqBwYR7dvqCd4yPPwqIIvoYbMy4AkjDn/cMOM/Ipob/55hVTxEe6ul79Ths02bNrF06VJuu+22B2tra3/Ti6rnEm06f8FYPYuBVmBVbwQhwO+MxMcrRNOX/0K0sP8L4KQx7jHDmjxL9BeNbgE83xmCN2/ezAsvvKCnpaXNXL169WsXaZgfGGb70f5INxjETwfuAD6Bvjs+GlBVtd/I3bZtG4sXL2bMmDFzDh48+OYAncP/aEywe/jGwbi+IvhwY2Njv9z1jh07ePbZZxk9evQjGzZseG2AkvsY0XPCM873vvuK4Np169b1C7nz5s2jpKRkzubNm5cPUHJnGnvxHBLrGulVjAT0PXv2XPTfvdq+fbuYPn26WLJkiZAkSQwfPvyxAexaVAEdhpPX73h5woQJ4uTJkxed4NLSUiHLshg/fvy8Ae47Vhkh2iWBZODDsWPHitraWhEKhS4Kwe+9954AxIwZM57nMvr854RNwHzgiWHDhlmnTp2K0+nsNeWapvHUU09RWVm5fOfOnY9cprf/fhQ7HbiL6Pme5N5U7HA4jnu93ucuUxvF/wP2ili1bzCgYwAAAABJRU5ErkJggg==
description: This integration randomly generates logs based on the template. It supports
  XDR/XSIAM HTTP Collector and Syslog Collector as log receivers.
detaileddescription: |-
  ### How to configure an instance.

  #### 1. Create an instance
  Add instance with the parameters below:
    - Instance Name: (Your own instance name)

    - SECTION: [XSIAM HTTP Collector]
      - Enable: ✅
      - XSIAM API endpoints: (Your API endpoints, e.g. https://api-xxx.paloaltonetworks.com/logs/v1/event)
      - API Key for CEF log: (Your API Key for your HTTP Collector (gzip enabled) to collect CEF logs)
      - Enable compression in gzip to upload events: ✅
      - Raw Log to CEF: ✅

  #### 2. Make sure that the instance is running
  Run !slp-get-running-status to get the running status.

  #### 3. Make sure that logs are ingested into your Cortex XSIAM.
    - dataset = panw_ngfw_cef_raw
    - dataset = panw_ngfw_traffic_raw
    - dataset = panw_ngfw_url_raw
    - dataset = panw_ngfw_threat_raw
    - dataset = fortinet_fortigate_raw
    - dataset = check_point_vpn_1_firewall_1_raw
    - dataset = cisco_asa_raw
    - dataset = zscaler_nssweblog_raw
    - dataset = microsoft_windows_raw
    - dataset = microsoft_dhcp_raw
    - dataset = squid_squid_raw
    - dataset = apache_httpd_raw
configuration:
- section: Connect
  display: Long Running Instance
  name: longRunning
  defaultvalue: "true"
  type: 8
  required: false
- section: Connect
  advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
- section: Connect
  advanced: true
  display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
- section: Connect
  advanced: true
  display: Log Sending Rate Limit
  name: rate_limit
  defaultvalue: 1 Mbps
  type: 0
  required: false
  additionalinfo: 0 = unlimited, default unit = Mbps
- section: XSIAM HTTP Collector
  display: Enable
  name: xsiam_hc_enable
  defaultvalue: "false"
  type: 8
  required: false
- section: XSIAM HTTP Collector
  display: XSIAM API endpoints
  name: xsiam_api_url
  type: 0
  required: false
- section: XSIAM HTTP Collector
  display: API Key for RAW log
  name: xsiam_hc_api_key_raw
  type: 4
  required: false
- section: XSIAM HTTP Collector
  display: API Key for CEF log
  name: xsiam_hc_api_key_cef
  type: 4
  required: false
- section: XSIAM HTTP Collector
  display: Enable compression in gzip to upload events
  name: xsiam_hc_compression
  defaultvalue: "true"
  type: 8
  required: false
  additionalinfo: Default = true
- section: XSIAM HTTP Collector
  advanced: true
  display: Transportation Format
  name: xsiam_hc_transportation_format
  type: 15
  required: false
  options:
  - RFC 3164
  - RFC 5424
  additionalinfo: Default = None (No headers are added to logs)
- section: XSIAM HTTP Collector
  advanced: true
  display: Enforce Log-specific Syslog Format
  name: xsiam_hc_enforce_log_spec_syslog_format
  type: 15
  required: false
  options:
  - adaptive
  - always
  additionalinfo: Default = None (Transportation Format is applied). Adaptive = Log-specific
    syslog headers are enforced only when the Transportation Format is specified.
- section: XSIAM HTTP Collector
  display: Raw Log to CEF
  name: xsiam_hc_raw_log_to_cef
  defaultvalue: "true"
  type: 8
  required: false
  additionalinfo: Convert non-CEF logs to CEF format to send logs
- section: XSIAM HTTP Collector
  advanced: true
  display: Upload buffer size
  name: xsiam_hc_buffer_size
  defaultvalue: 1 MB
  type: 0
  required: true
  additionalinfo: Max - 15MB
- section: Syslog Collector
  display: Enable
  name: syslog_transport_enable
  defaultvalue: "false"
  type: 8
  required: false
- section: Syslog Collector
  display: Syslog Server
  name: syslog_transport_address
  type: 0
  required: false
  additionalinfo: 'e.g. 192.168.1.2:514 (Default Port: 514)'
- section: Syslog Collector
  display: Protocol
  name: syslog_transport_protocol
  defaultvalue: UDP
  type: 15
  required: true
  options:
  - UDP
  - TCP
- section: Syslog Collector
  advanced: true
  display: Syslog Format
  name: syslog_transport_format
  defaultvalue: RFC 5424
  type: 15
  required: true
  options:
  - RFC 3164
  - RFC 5424
- section: Syslog Collector
  advanced: true
  display: Enforce Log-specific Syslog Format
  name: syslog_transport_enforce_log_spec_format
  type: 15
  required: false
  options:
  - adaptive
  - always
  additionalinfo: Default = None (Transportation Format is applied).
- section: Default Scenario
  advanced: true
  display: Default Scenario List
  name: default_scenario_list
  defaultvalue: normal,irregular
  type: 16
  required: false
  options:
  - normal
  - irregular
  additionalinfo: Choose the default scenarios to use
- section: Default Scenario
  advanced: true
  display: Tap products - Internal Network
  name: default_scenario_internal_tap_products
  defaultvalue: ngfw,checkpoint-fw,fortigate
  type: 16
  required: false
  options:
  - ngfw
  - checkpoint-fw
  - fortigate
  additionalinfo: Tap products in the internal network
- section: Default Scenario
  advanced: true
  display: Squid Log Format - Internal Network
  name: default_scenario_internal_proxy_squid_log_formats
  defaultvalue: squid,common,combined
  type: 16
  required: false
  options:
  - squid
  - common
  - combined
  additionalinfo: Log format of the squid proxy in the internal network
- section: Default Scenario
  advanced: true
  display: Apache HTTPd Log Format - Internal Network
  name: default_scenario_internal_web_apache_log_formats
  defaultvalue: common,combined
  type: 16
  required: false
  options:
  - common
  - combined
  additionalinfo: Log format of the apache httpd in the internal network
- section: Default Scenario
  advanced: true
  display: Tap products - External Network
  name: default_scenario_external_tap_products
  defaultvalue: zscaler-nssweb
  type: 16
  required: false
  options:
  - zscaler-nssweb
  additionalinfo: Tap products in the external network
- section: Default Scenario
  advanced: true
  display: Proxy Products - External Network
  name: default_scenario_external_proxy_products
  type: 16
  required: false
  options:
  - zscaler-nssweb
  additionalinfo: Proxy products in the external network
- section: Custom Scenario
  advanced: true
  display: Enable
  name: custom_scenario_enable
  defaultvalue: "false"
  type: 8
  required: false
- section: Custom Scenario
  advanced: true
  display: Scenario JSON
  name: custom_scenario_json
  type: 12
  required: false
- section: Custom Scenario
  advanced: true
  display: Scenario URL
  name: custom_scenario_url
  type: 0
  required: false
- section: Custom Scenario
  advanced: true
  display: Username
  displaypassword: Password
  name: custom_scenario_url_creds
  type: 9
  required: false
- section: Custom Scenario
  advanced: true
  display: ZIP Password
  name: custom_scenario_zip_password
  type: 4
  required: false
- section: Scenario
  advanced: true
  display: Enable Auto Resume Jobs
  name: scenario_enable_resume_scheduled_jobs
  defaultvalue: "true"
  type: 8
  required: false
  additionalinfo: Enable to resume scheduled times for scheduled jobs when the last
    run didn't finish
- section: Scenario
  advanced: true
  display: Scenario Run Mode
  name: scenario_run_mode
  defaultvalue: random
  type: 15
  required: true
  options:
  - random
  - sequential
- section: Scenario
  advanced: true
  display: Number of loop count to play scenarios (sources)
  name: scenario_sources_loop
  type: 0
  required: false
  additionalinfo: blank - endless if sources exist in the scenario.
- section: Scenario
  advanced: true
  display: Number of loop count to play scenarios (jobs)
  name: scenario_jobs_loop
  type: 0
  required: false
  additionalinfo: blank - endless if jobs exist in the scenario.
- section: Syslog Format
  advanced: true
  display: Preferred Syslog Headers
  name: syslog_preferred_headers
  defaultvalue: bind=RFC 3164, squid=RFC 3164, apache-httpd=RFC 3164
  type: 0
  required: false
  additionalinfo: Log-specific preferred syslog header format. The settings are applied
    by syslog header enforcement.
- section: Syslog Format
  advanced: true
  display: Syslog Falicity
  name: syslog_facility
  defaultvalue: local0
  type: 15
  required: false
  options:
  - kern
  - user
  - mail
  - daemon
  - auth
  - syslog
  - lpr
  - news
  - uucp
  - cron
  - authpriv
  - ftp
  - local0
  - local1
  - local2
  - local3
  - local4
  - local5
  - local6
  - local7
  additionalinfo: Default = local0
- section: Syslog Format
  advanced: true
  display: Syslog Severity
  name: syslog_severity
  defaultvalue: info
  type: 15
  required: false
  options:
  - emerg
  - alert
  - crit
  - err
  - warning
  - notice
  - info
  - debug
  additionalinfo: Default = info
- section: Miscellaneous
  advanced: true
  display: Logging Time Zone Offset
  name: timezone_logging
  defaultvalue: "+00:00"
  type: 0
  required: false
  additionalinfo: Default = +00:00
- section: Miscellaneous
  advanced: true
  display: Display Time Zone Offset
  name: timezone_display
  defaultvalue: "+00:00"
  type: 0
  required: false
  additionalinfo: Default = +00:00
- section: Miscellaneous
  advanced: true
  display: Enable Alert Creation
  name: enable_alert_creation
  defaultvalue: "false"
  type: 8
  required: false
- display: Alert type
  name: alertType
  type: 13
  required: false
- display: Alerts Fetch Interval
  name: alertFetchInterval
  defaultvalue: "1"
  type: 19
  required: false
script:
  script: |+
    import os
    import os.path
    import io
    import re
    import sys
    import gzip
    import time
    import copy
    import uuid
    import enum
    import queue
    import socket
    import string
    import random
    import hashlib
    import zipfile
    import aiohttp
    import asyncio
    import datetime
    import threading
    import ipaddress
    import functools
    import itertools
    import traceback
    import urllib.parse
    from collections import defaultdict, namedtuple
    from abc import ABCMeta, abstractmethod
    from collections.abc import Iterator
    from typing import Tuple, Any, NamedTuple, DefaultDict, Callable, Self, Coroutine, Awaitable
    from types import TracebackType


    DEFAULT_SOCKET_TIMEOUT = 30
    DEFAULT_LOG_FLUSH_INTERVAL = 10
    DEFAULT_STATUS_UPDATE_INTERVAL = 10
    DEFAULT_HEC_UPLOAD_BUFFER_SIZE = 1 * 1024 * 1024
    DEFAULT_HTTP_RETRIES = 3
    MAX_HEC_UPLOAD_BUFFER_SIZE = 15 * 1024 * 1024
    INTEGRATION_NAME = 'Scenario Log Player'


    class SyslogHeaderType(enum.StrEnum):
        RFC_3164 = 'RFC 3164'
        RFC_5424 = 'RFC 5424'


    class SyslogHeaderTypeEnforcement(enum.StrEnum):
        ADAPTIVE = enum.auto()
        ALWAYS = enum.auto()


    FILE_EXTENSION_TO_MIME_TYPE = {
        '.ez': 'application/andrew-inset',
        '.aw': 'application/applixware',
        '.atom': 'application/atom+xml',
        '.atomcat': 'application/atomcat+xml',
        '.atomsvc': 'application/atomsvc+xml',
        '.bdoc': 'application/x-bdoc',
        '.ccxml': 'application/ccxml+xml',
        '.cdmia': 'application/cdmi-capability',
        '.cdmic': 'application/cdmi-container',
        '.cdmid': 'application/cdmi-domain',
        '.cdmio': 'application/cdmi-object',
        '.cdmiq': 'application/cdmi-queue',
        '.cu': 'application/cu-seeme',
        '.mpd': 'application/dash+xml',
        '.davmount': 'application/davmount+xml',
        '.dbk': 'application/docbook+xml',
        '.dssc': 'application/dssc+der',
        '.xdssc': 'application/dssc+xml',
        '.ecma': 'application/ecmascript',
        '.emma': 'application/emma+xml',
        '.epub': 'application/epub+zip',
        '.exi': 'application/exi',
        '.pfr': 'application/font-tdpfr',
        '.woff': 'font/woff',
        '.woff2': 'font/woff2',
        '.geojson': 'application/geo+json',
        '.gml': 'application/gml+xml',
        '.gpx': 'application/gpx+xml',
        '.gxf': 'application/gxf',
        '.gz': 'application/gzip',
        '.stk': 'application/hyperstudio',
        '.inkml': 'application/inkml+xml',
        '.ink': 'application/inkml+xml',
        '.ipfix': 'application/ipfix',
        '.war': 'application/java-archive',
        '.jar': 'application/java-archive',
        '.ear': 'application/java-archive',
        '.ser': 'application/java-serialized-object',
        '.class': 'application/java-vm',
        '.mjs': 'text/javascript',
        '.js': 'application/javascript',
        '.json': 'application/json',
        '.map': 'application/json',
        '.json5': 'application/json5',
        '.jsonml': 'application/jsonml+json',
        '.jsonld': 'application/ld+json',
        '.lostxml': 'application/lost+xml',
        '.hqx': 'application/mac-binhex40',
        '.cpt': 'application/mac-compactpro',
        '.mads': 'application/mads+xml',
        '.webmanifest': 'application/manifest+json',
        '.mrc': 'application/marc',
        '.mrcx': 'application/marcxml+xml',
        '.nb': 'application/mathematica',
        '.ma': 'application/mathematica',
        '.mb': 'application/mathematica',
        '.mathml': 'application/mathml+xml',
        '.mbox': 'application/mbox',
        '.mscml': 'application/mediaservercontrol+xml',
        '.metalink': 'application/metalink+xml',
        '.meta4': 'application/metalink4+xml',
        '.mets': 'application/mets+xml',
        '.mods': 'application/mods+xml',
        '.mp21': 'application/mp21',
        '.m21': 'application/mp21',
        '.mp4s': 'application/mp4',
        '.m4p': 'application/mp4',
        '.doc': 'application/msword',
        '.dot': 'application/msword',
        '.mxf': 'application/mxf',
        '.msm': 'application/octet-stream',
        '.bpk': 'application/octet-stream',
        '.deploy': 'application/octet-stream',
        '.mar': 'application/octet-stream',
        '.dms': 'application/octet-stream',
        '.pkg': 'application/octet-stream',
        '.elc': 'application/octet-stream',
        '.lrf': 'application/octet-stream',
        '.buffer': 'application/octet-stream',
        '.deb': 'application/x-debian-package',
        '.dll': 'application/x-msdownload',
        '.msi': 'application/x-msdownload',
        '.dmg': 'application/x-apple-diskimage',
        '.distz': 'application/octet-stream',
        '.iso': 'application/x-iso9660-image',
        '.dump': 'application/octet-stream',
        '.img': 'application/octet-stream',
        '.dist': 'application/octet-stream',
        '.exe': 'application/x-msdownload',
        '.msp': 'application/octet-stream',
        '.so': 'application/octet-stream',
        '.bin': 'application/octet-stream',
        '.oda': 'application/oda',
        '.opf': 'application/oebps-package+xml',
        '.ogx': 'application/ogg',
        '.omdoc': 'application/omdoc+xml',
        '.onepkg': 'application/onenote',
        '.onetoc2': 'application/onenote',
        '.onetoc': 'application/onenote',
        '.onetmp': 'application/onenote',
        '.oxps': 'application/oxps',
        '.xer': 'application/patch-ops-error+xml',
        '.pdf': 'application/pdf',
        '.pgp': 'application/pgp-encrypted',
        '.sig': 'application/pgp-signature',
        '.asc': 'application/pgp-signature',
        '.prf': 'application/pics-rules',
        '.p10': 'application/pkcs10',
        '.p7c': 'application/pkcs7-mime',
        '.p7m': 'application/pkcs7-mime',
        '.p7s': 'application/pkcs7-signature',
        '.p8': 'application/pkcs8',
        '.ac': 'application/pkix-attr-cert',
        '.cer': 'application/pkix-cert',
        '.crl': 'application/pkix-crl',
        '.pkipath': 'application/pkix-pkipath',
        '.pki': 'application/pkixcmp',
        '.pls': 'application/pls+xml',
        '.ps': 'application/postscript',
        '.ai': 'application/postscript',
        '.eps': 'application/postscript',
        '.cww': 'application/prs.cww',
        '.pskcxml': 'application/pskc+xml',
        '.rdf': 'application/rdf+xml',
        '.rif': 'application/reginfo+xml',
        '.rnc': 'application/relax-ng-compact-syntax',
        '.rl': 'application/resource-lists+xml',
        '.rld': 'application/resource-lists-diff+xml',
        '.rs': 'application/rls-services+xml',
        '.gbr': 'application/rpki-ghostbusters',
        '.mft': 'application/rpki-manifest',
        '.roa': 'application/rpki-roa',
        '.rsd': 'application/rsd+xml',
        '.rss': 'application/rss+xml',
        '.rtf': 'text/rtf',
        '.sbml': 'application/sbml+xml',
        '.scq': 'application/scvp-cv-request',
        '.scs': 'application/scvp-cv-response',
        '.spq': 'application/scvp-vp-request',
        '.spp': 'application/scvp-vp-response',
        '.sdp': 'application/sdp',
        '.setpay': 'application/set-payment-initiation',
        '.setreg': 'application/set-registration-initiation',
        '.shf': 'application/shf+xml',
        '.smil': 'application/smil+xml',
        '.smi': 'application/smil+xml',
        '.rq': 'application/sparql-query',
        '.srx': 'application/sparql-results+xml',
        '.gram': 'application/srgs',
        '.grxml': 'application/srgs+xml',
        '.sru': 'application/sru+xml',
        '.ssdl': 'application/ssdl+xml',
        '.ssml': 'application/ssml+xml',
        '.teicorpus': 'application/tei+xml',
        '.tei': 'application/tei+xml',
        '.tfi': 'application/thraud+xml',
        '.tsd': 'application/timestamped-data',
        '.plb': 'application/vnd.3gpp.pic-bw-large',
        '.psb': 'application/vnd.3gpp.pic-bw-small',
        '.pvb': 'application/vnd.3gpp.pic-bw-var',
        '.tcap': 'application/vnd.3gpp2.tcap',
        '.pwn': 'application/vnd.3m.post-it-notes',
        '.aso': 'application/vnd.accpac.simply.aso',
        '.imp': 'application/vnd.accpac.simply.imp',
        '.acu': 'application/vnd.acucobol',
        '.atc': 'application/vnd.acucorp',
        '.acutc': 'application/vnd.acucorp',
        '.air': 'application/vnd.adobe.air-application-installer-package+zip',
        '.fcdt': 'application/vnd.adobe.formscentral.fcdt',
        '.fxp': 'application/vnd.adobe.fxp',
        '.fxpl': 'application/vnd.adobe.fxp',
        '.xdp': 'application/vnd.adobe.xdp+xml',
        '.xfdf': 'application/vnd.adobe.xfdf',
        '.ahead': 'application/vnd.ahead.space',
        '.azf': 'application/vnd.airzip.filesecure.azf',
        '.azs': 'application/vnd.airzip.filesecure.azs',
        '.azw': 'application/vnd.amazon.ebook',
        '.acc': 'application/vnd.americandynamics.acc',
        '.ami': 'application/vnd.amiga.ami',
        '.apk': 'application/vnd.android.package-archive',
        '.cii': 'application/vnd.anser-web-certificate-issue-initiation',
        '.fti': 'application/vnd.anser-web-funds-transfer-initiation',
        '.atx': 'application/vnd.antix.game-component',
        '.mpkg': 'application/vnd.apple.installer+xml',
        '.m3u8': 'application/vnd.apple.mpegurl',
        '.pkpass': 'application/vnd.apple.pkpass',
        '.swi': 'application/vnd.aristanetworks.swi',
        '.iota': 'application/vnd.astraea-software.iota',
        '.aep': 'application/vnd.audiograph',
        '.mpm': 'application/vnd.blueice.multipass',
        '.bmi': 'application/vnd.bmi',
        '.rep': 'application/vnd.businessobjects',
        '.cdxml': 'application/vnd.chemdraw+xml',
        '.mmd': 'application/vnd.chipnuts.karaoke-mmd',
        '.cdy': 'application/vnd.cinderella',
        '.cla': 'application/vnd.claymore',
        '.rp9': 'application/vnd.cloanto.rp9',
        '.c4d': 'application/vnd.clonk.c4group',
        '.c4u': 'application/vnd.clonk.c4group',
        '.c4g': 'application/vnd.clonk.c4group',
        '.c4p': 'application/vnd.clonk.c4group',
        '.c4f': 'application/vnd.clonk.c4group',
        '.c11amc': 'application/vnd.cluetrust.cartomobile-config',
        '.c11amz': 'application/vnd.cluetrust.cartomobile-config-pkg',
        '.csp': 'application/vnd.commonspace',
        '.cdbcmsg': 'application/vnd.contact.cmsg',
        '.cmc': 'application/vnd.cosmocaller',
        '.clkx': 'application/vnd.crick.clicker',
        '.clkk': 'application/vnd.crick.clicker.keyboard',
        '.clkp': 'application/vnd.crick.clicker.palette',
        '.clkt': 'application/vnd.crick.clicker.template',
        '.clkw': 'application/vnd.crick.clicker.wordbank',
        '.wbs': 'application/vnd.criticaltools.wbs+xml',
        '.pml': 'application/vnd.ctc-posml',
        '.ppd': 'application/vnd.cups-ppd',
        '.car': 'application/vnd.curl.car',
        '.pcurl': 'application/vnd.curl.pcurl',
        '.dart': 'application/vnd.dart',
        '.rdz': 'application/vnd.data-vision.rdz',
        '.uvf': 'application/vnd.dece.data',
        '.uvvd': 'application/vnd.dece.data',
        '.uvd': 'application/vnd.dece.data',
        '.uvvf': 'application/vnd.dece.data',
        '.uvvt': 'application/vnd.dece.ttml+xml',
        '.uvt': 'application/vnd.dece.ttml+xml',
        '.uvvx': 'application/vnd.dece.unspecified',
        '.uvx': 'application/vnd.dece.unspecified',
        '.uvvz': 'application/vnd.dece.zip',
        '.uvz': 'application/vnd.dece.zip',
        '.fe_launch': 'application/vnd.denovo.fcselayout-link',
        '.dna': 'application/vnd.dna',
        '.mlp': 'application/vnd.dolby.mlp',
        '.dpg': 'application/vnd.dpgraph',
        '.dfac': 'application/vnd.dreamfactory',
        '.kpxx': 'application/vnd.ds-keypoint',
        '.ait': 'application/vnd.dvb.ait',
        '.svc': 'application/vnd.dvb.service',
        '.geo': 'application/vnd.dynageo',
        '.mag': 'application/vnd.ecowin.chart',
        '.nml': 'application/vnd.enliven',
        '.esf': 'application/vnd.epson.esf',
        '.msf': 'application/vnd.epson.msf',
        '.qam': 'application/vnd.epson.quickanime',
        '.slt': 'application/vnd.epson.salt',
        '.ssf': 'application/vnd.epson.ssf',
        '.et3': 'application/vnd.eszigno3+xml',
        '.es3': 'application/vnd.eszigno3+xml',
        '.ez2': 'application/vnd.ezpix-album',
        '.ez3': 'application/vnd.ezpix-package',
        '.fdf': 'application/vnd.fdf',
        '.mseed': 'application/vnd.fdsn.mseed',
        '.dataless': 'application/vnd.fdsn.seed',
        '.seed': 'application/vnd.fdsn.seed',
        '.gph': 'application/vnd.flographit',
        '.ftc': 'application/vnd.fluxtime.clip',
        '.book': 'application/vnd.framemaker',
        '.maker': 'application/vnd.framemaker',
        '.fm': 'application/vnd.framemaker',
        '.frame': 'application/vnd.framemaker',
        '.fnc': 'application/vnd.frogans.fnc',
        '.ltf': 'application/vnd.frogans.ltf',
        '.fsc': 'application/vnd.fsc.weblaunch',
        '.oas': 'application/vnd.fujitsu.oasys',
        '.oa2': 'application/vnd.fujitsu.oasys2',
        '.oa3': 'application/vnd.fujitsu.oasys3',
        '.fg5': 'application/vnd.fujitsu.oasysgp',
        '.bh2': 'application/vnd.fujitsu.oasysprs',
        '.ddd': 'application/vnd.fujixerox.ddd',
        '.xdw': 'application/vnd.fujixerox.docuworks',
        '.xbd': 'application/vnd.fujixerox.docuworks.binder',
        '.fzs': 'application/vnd.fuzzysheet',
        '.txd': 'application/vnd.genomatix.tuxedo',
        '.ggb': 'application/vnd.geogebra.file',
        '.ggt': 'application/vnd.geogebra.tool',
        '.gex': 'application/vnd.geometry-explorer',
        '.gre': 'application/vnd.geometry-explorer',
        '.gxt': 'application/vnd.geonext',
        '.g2w': 'application/vnd.geoplan',
        '.g3w': 'application/vnd.geospace',
        '.gmx': 'application/vnd.gmx',
        '.gdoc': 'application/vnd.google-apps.document',
        '.gslides': 'application/vnd.google-apps.presentation',
        '.gsheet': 'application/vnd.google-apps.spreadsheet',
        '.kml': 'application/vnd.google-earth.kml+xml',
        '.kmz': 'application/vnd.google-earth.kmz',
        '.gqs': 'application/vnd.grafeq',
        '.gqf': 'application/vnd.grafeq',
        '.gac': 'application/vnd.groove-account',
        '.ghf': 'application/vnd.groove-help',
        '.gim': 'application/vnd.groove-identity-message',
        '.grv': 'application/vnd.groove-injector',
        '.gtm': 'application/vnd.groove-tool-message',
        '.tpl': 'application/vnd.groove-tool-template',
        '.vcg': 'application/vnd.groove-vcard',
        '.hal': 'application/vnd.hal+xml',
        '.zmm': 'application/vnd.handheld-entertainment+xml',
        '.hbci': 'application/vnd.hbci',
        '.les': 'application/vnd.hhe.lesson-player',
        '.hpgl': 'application/vnd.hp-hpgl',
        '.hpid': 'application/vnd.hp-hpid',
        '.hps': 'application/vnd.hp-hps',
        '.jlt': 'application/vnd.hp-jlyt',
        '.pcl': 'application/vnd.hp-pcl',
        '.pclxl': 'application/vnd.hp-pclxl',
        '.sfd-hdstx': 'application/vnd.hydrostatix.sof-data',
        '.mpy': 'application/vnd.ibm.minipay',
        '.listafp': 'application/vnd.ibm.modcap',
        '.afp': 'application/vnd.ibm.modcap',
        '.list3820': 'application/vnd.ibm.modcap',
        '.irm': 'application/vnd.ibm.rights-management',
        '.sc': 'application/vnd.ibm.secure-container',
        '.icm': 'application/vnd.iccprofile',
        '.icc': 'application/vnd.iccprofile',
        '.igl': 'application/vnd.igloader',
        '.ivp': 'application/vnd.immervision-ivp',
        '.ivu': 'application/vnd.immervision-ivu',
        '.igm': 'application/vnd.insors.igm',
        '.xpx': 'application/vnd.intercon.formnet',
        '.xpw': 'application/vnd.intercon.formnet',
        '.i2g': 'application/vnd.intergeo',
        '.qbo': 'application/vnd.intu.qbo',
        '.qfx': 'application/vnd.intu.qfx',
        '.rcprofile': 'application/vnd.ipunplugged.rcprofile',
        '.irp': 'application/vnd.irepository.package+xml',
        '.xpr': 'application/vnd.is-xpr',
        '.fcs': 'application/vnd.isac.fcs',
        '.jam': 'application/vnd.jam',
        '.rms': 'application/vnd.jcp.javame.midlet-rms',
        '.jisp': 'application/vnd.jisp',
        '.joda': 'application/vnd.joost.joda-archive',
        '.ktz': 'application/vnd.kahootz',
        '.ktr': 'application/vnd.kahootz',
        '.karbon': 'application/vnd.kde.karbon',
        '.chrt': 'application/vnd.kde.kchart',
        '.kfo': 'application/vnd.kde.kformula',
        '.flw': 'application/vnd.kde.kivio',
        '.kon': 'application/vnd.kde.kontour',
        '.kpr': 'application/vnd.kde.kpresenter',
        '.kpt': 'application/vnd.kde.kpresenter',
        '.ksp': 'application/vnd.kde.kspread',
        '.kwt': 'application/vnd.kde.kword',
        '.kwd': 'application/vnd.kde.kword',
        '.htke': 'application/vnd.kenameaapp',
        '.kia': 'application/vnd.kidspiration',
        '.knp': 'application/vnd.kinar',
        '.kne': 'application/vnd.kinar',
        '.skt': 'application/vnd.koan',
        '.skp': 'application/vnd.koan',
        '.skd': 'application/vnd.koan',
        '.skm': 'application/vnd.koan',
        '.sse': 'application/vnd.kodak-descriptor',
        '.lasxml': 'application/vnd.las.las+xml',
        '.lbd': 'application/vnd.llamagraphics.life-balance.desktop',
        '.lbe': 'application/vnd.llamagraphics.life-balance.exchange+xml',
        '.123': 'application/vnd.lotus-1-2-3',
        '.apr': 'application/vnd.lotus-approach',
        '.pre': 'application/vnd.lotus-freelance',
        '.nsf': 'application/vnd.lotus-notes',
        '.org': 'text/x-org',
        '.scm': 'application/vnd.lotus-screencam',
        '.lwp': 'application/vnd.lotus-wordpro',
        '.portpkg': 'application/vnd.macports.portpkg',
        '.mcd': 'application/vnd.mcd',
        '.mc1': 'application/vnd.medcalcdata',
        '.cdkey': 'application/vnd.mediastation.cdkey',
        '.mwf': 'application/vnd.mfer',
        '.mfm': 'application/vnd.mfmp',
        '.flo': 'application/vnd.micrografx.flo',
        '.igx': 'application/vnd.micrografx.igx',
        '.mif': 'application/vnd.mif',
        '.daf': 'application/vnd.mobius.daf',
        '.dis': 'application/vnd.mobius.dis',
        '.mbk': 'application/vnd.mobius.mbk',
        '.mqy': 'application/vnd.mobius.mqy',
        '.msl': 'application/vnd.mobius.msl',
        '.plc': 'application/vnd.mobius.plc',
        '.txf': 'application/vnd.mobius.txf',
        '.mpn': 'application/vnd.mophun.application',
        '.mpc': 'application/vnd.mophun.certificate',
        '.xul': 'application/vnd.mozilla.xul+xml',
        '.cil': 'application/vnd.ms-artgalry',
        '.cab': 'application/vnd.ms-cab-compressed',
        '.xlm': 'application/vnd.ms-excel',
        '.xlc': 'application/vnd.ms-excel',
        '.xla': 'application/vnd.ms-excel',
        '.xlw': 'application/vnd.ms-excel',
        '.xlt': 'application/vnd.ms-excel',
        '.xls': 'application/vnd.ms-excel',
        '.xlam': 'application/vnd.ms-excel.addin.macroenabled.12',
        '.xlsb': 'application/vnd.ms-excel.sheet.binary.macroenabled.12',
        '.xlsm': 'application/vnd.ms-excel.sheet.macroenabled.12',
        '.xltm': 'application/vnd.ms-excel.template.macroenabled.12',
        '.eot': 'application/vnd.ms-fontobject',
        '.chm': 'application/vnd.ms-htmlhelp',
        '.ims': 'application/vnd.ms-ims',
        '.lrm': 'application/vnd.ms-lrm',
        '.thmx': 'application/vnd.ms-officetheme',
        '.msg': 'application/vnd.ms-outlook',
        '.cat': 'application/vnd.ms-pki.seccat',
        '.stl': 'application/vnd.ms-pki.stl',
        '.pps': 'application/vnd.ms-powerpoint',
        '.ppt': 'application/vnd.ms-powerpoint',
        '.pot': 'application/vnd.ms-powerpoint',
        '.ppam': 'application/vnd.ms-powerpoint.addin.macroenabled.12',
        '.pptm': 'application/vnd.ms-powerpoint.presentation.macroenabled.12',
        '.sldm': 'application/vnd.ms-powerpoint.slide.macroenabled.12',
        '.ppsm': 'application/vnd.ms-powerpoint.slideshow.macroenabled.12',
        '.potm': 'application/vnd.ms-powerpoint.template.macroenabled.12',
        '.mpp': 'application/vnd.ms-project',
        '.mpt': 'application/vnd.ms-project',
        '.docm': 'application/vnd.ms-word.document.macroenabled.12',
        '.dotm': 'application/vnd.ms-word.template.macroenabled.12',
        '.wps': 'application/vnd.ms-works',
        '.wdb': 'application/vnd.ms-works',
        '.wcm': 'application/vnd.ms-works',
        '.wks': 'application/vnd.ms-works',
        '.wpl': 'application/vnd.ms-wpl',
        '.xps': 'application/vnd.ms-xpsdocument',
        '.mseq': 'application/vnd.mseq',
        '.mus': 'application/vnd.musician',
        '.msty': 'application/vnd.muvee.style',
        '.taglet': 'application/vnd.mynfc',
        '.nlu': 'application/vnd.neurolanguage.nlu',
        '.ntf': 'application/vnd.nitf',
        '.nitf': 'application/vnd.nitf',
        '.nnd': 'application/vnd.noblenet-directory',
        '.nns': 'application/vnd.noblenet-sealer',
        '.nnw': 'application/vnd.noblenet-web',
        '.ngdat': 'application/vnd.nokia.n-gage.data',
        '.n-gage': 'application/vnd.nokia.n-gage.symbian.install',
        '.rpst': 'application/vnd.nokia.radio-preset',
        '.rpss': 'application/vnd.nokia.radio-presets',
        '.edm': 'application/vnd.novadigm.edm',
        '.edx': 'application/vnd.novadigm.edx',
        '.ext': 'application/vnd.novadigm.ext',
        '.odc': 'application/vnd.oasis.opendocument.chart',
        '.otc': 'application/vnd.oasis.opendocument.chart-template',
        '.odb': 'application/vnd.oasis.opendocument.database',
        '.odf': 'application/vnd.oasis.opendocument.formula',
        '.odft': 'application/vnd.oasis.opendocument.formula-template',
        '.odg': 'application/vnd.oasis.opendocument.graphics',
        '.otg': 'application/vnd.oasis.opendocument.graphics-template',
        '.odi': 'application/vnd.oasis.opendocument.image',
        '.oti': 'application/vnd.oasis.opendocument.image-template',
        '.odp': 'application/vnd.oasis.opendocument.presentation',
        '.otp': 'application/vnd.oasis.opendocument.presentation-template',
        '.ods': 'application/vnd.oasis.opendocument.spreadsheet',
        '.ots': 'application/vnd.oasis.opendocument.spreadsheet-template',
        '.odt': 'application/vnd.oasis.opendocument.text',
        '.odm': 'application/vnd.oasis.opendocument.text-master',
        '.ott': 'application/vnd.oasis.opendocument.text-template',
        '.oth': 'application/vnd.oasis.opendocument.text-web',
        '.xo': 'application/vnd.olpc-sugar',
        '.dd2': 'application/vnd.oma.dd2+xml',
        '.oxt': 'application/vnd.openofficeorg.extension',
        '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
        '.sldx': 'application/vnd.openxmlformats-officedocument.presentationml.slide',
        '.ppsx': 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',
        '.potx': 'application/vnd.openxmlformats-officedocument.presentationml.template',
        '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        '.xltx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
        '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        '.dotx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
        '.mgp': 'application/vnd.osgeo.mapguide.package',
        '.dp': 'application/vnd.osgi.dp',
        '.esa': 'application/vnd.osgi.subsystem',
        '.pqa': 'application/vnd.palm',
        '.oprc': 'application/vnd.palm',
        '.pdb': 'application/x-pilot',
        '.paw': 'application/vnd.pawaafile',
        '.str': 'application/vnd.pg.format',
        '.ei6': 'application/vnd.pg.osasli',
        '.efif': 'application/vnd.picsel',
        '.wg': 'application/vnd.pmi.widget',
        '.plf': 'application/vnd.pocketlearn',
        '.pbd': 'application/vnd.powerbuilder6',
        '.box': 'application/vnd.previewsystems.box',
        '.mgz': 'application/vnd.proteus.magazine',
        '.qps': 'application/vnd.publishare-delta-tree',
        '.ptid': 'application/vnd.pvi.ptid1',
        '.qwd': 'application/vnd.quark.quarkxpress',
        '.qxb': 'application/vnd.quark.quarkxpress',
        '.qxd': 'application/vnd.quark.quarkxpress',
        '.qxt': 'application/vnd.quark.quarkxpress',
        '.qxl': 'application/vnd.quark.quarkxpress',
        '.qwt': 'application/vnd.quark.quarkxpress',
        '.bed': 'application/vnd.realvnc.bed',
        '.mxl': 'application/vnd.recordare.musicxml',
        '.musicxml': 'application/vnd.recordare.musicxml+xml',
        '.cryptonote': 'application/vnd.rig.cryptonote',
        '.cod': 'application/vnd.rim.cod',
        '.rm': 'application/vnd.rn-realmedia',
        '.rmvb': 'application/vnd.rn-realmedia-vbr',
        '.link66': 'application/vnd.route66.link66+xml',
        '.st': 'application/vnd.sailingtracker.track',
        '.see': 'application/vnd.seemail',
        '.sema': 'application/vnd.sema',
        '.semd': 'application/vnd.semd',
        '.semf': 'application/vnd.semf',
        '.ifm': 'application/vnd.shana.informed.formdata',
        '.itp': 'application/vnd.shana.informed.formtemplate',
        '.iif': 'application/vnd.shana.informed.interchange',
        '.ipk': 'application/vnd.shana.informed.package',
        '.twd': 'application/vnd.simtech-mindmapper',
        '.twds': 'application/vnd.simtech-mindmapper',
        '.mmf': 'application/vnd.smaf',
        '.teacher': 'application/vnd.smart.teacher',
        '.sdkm': 'application/vnd.solent.sdkm+xml',
        '.sdkd': 'application/vnd.solent.sdkm+xml',
        '.dxp': 'application/vnd.spotfire.dxp',
        '.sfs': 'application/vnd.spotfire.sfs',
        '.sdc': 'application/vnd.stardivision.calc',
        '.sda': 'application/vnd.stardivision.draw',
        '.sdd': 'application/vnd.stardivision.impress',
        '.smf': 'application/vnd.stardivision.math',
        '.vor': 'application/vnd.stardivision.writer',
        '.sdw': 'application/vnd.stardivision.writer',
        '.sgl': 'application/vnd.stardivision.writer-global',
        '.smzip': 'application/vnd.stepmania.package',
        '.sm': 'application/vnd.stepmania.stepchart',
        '.wadl': 'application/vnd.sun.wadl+xml',
        '.sxc': 'application/vnd.sun.xml.calc',
        '.stc': 'application/vnd.sun.xml.calc.template',
        '.sxd': 'application/vnd.sun.xml.draw',
        '.std': 'application/vnd.sun.xml.draw.template',
        '.sxi': 'application/vnd.sun.xml.impress',
        '.sti': 'application/vnd.sun.xml.impress.template',
        '.sxm': 'application/vnd.sun.xml.math',
        '.sxw': 'application/vnd.sun.xml.writer',
        '.sxg': 'application/vnd.sun.xml.writer.global',
        '.stw': 'application/vnd.sun.xml.writer.template',
        '.sus': 'application/vnd.sus-calendar',
        '.susp': 'application/vnd.sus-calendar',
        '.svd': 'application/vnd.svd',
        '.sis': 'application/vnd.symbian.install',
        '.sisx': 'application/vnd.symbian.install',
        '.xsm': 'application/vnd.syncml+xml',
        '.bdm': 'application/vnd.syncml.dm+wbxml',
        '.xdm': 'application/vnd.syncml.dm+xml',
        '.tao': 'application/vnd.tao.intent-module-archive',
        '.cap': 'application/vnd.tcpdump.pcap',
        '.dmp': 'application/vnd.tcpdump.pcap',
        '.pcap': 'application/vnd.tcpdump.pcap',
        '.tmo': 'application/vnd.tmobile-livetv',
        '.tpt': 'application/vnd.trid.tpt',
        '.mxs': 'application/vnd.triscape.mxs',
        '.tra': 'application/vnd.trueapp',
        '.ufd': 'application/vnd.ufdl',
        '.ufdl': 'application/vnd.ufdl',
        '.utz': 'application/vnd.uiq.theme',
        '.umj': 'application/vnd.umajin',
        '.unityweb': 'application/vnd.unity',
        '.uoml': 'application/vnd.uoml+xml',
        '.vcx': 'application/vnd.vcx',
        '.vst': 'application/vnd.visio',
        '.vsd': 'application/vnd.visio',
        '.vsw': 'application/vnd.visio',
        '.vss': 'application/vnd.visio',
        '.vis': 'application/vnd.visionary',
        '.vsf': 'application/vnd.vsf',
        '.wbxml': 'application/vnd.wap.wbxml',
        '.wmlc': 'application/vnd.wap.wmlc',
        '.wmlsc': 'application/vnd.wap.wmlscriptc',
        '.wtb': 'application/vnd.webturbo',
        '.nbp': 'application/vnd.wolfram.player',
        '.wpd': 'application/vnd.wordperfect',
        '.wqd': 'application/vnd.wqd',
        '.stf': 'application/vnd.wt.stf',
        '.xar': 'application/vnd.xara',
        '.xfdl': 'application/vnd.xfdl',
        '.hvd': 'application/vnd.yamaha.hv-dic',
        '.hvs': 'application/vnd.yamaha.hv-script',
        '.hvp': 'application/vnd.yamaha.hv-voice',
        '.osf': 'application/vnd.yamaha.openscoreformat',
        '.osfpvg': 'application/vnd.yamaha.openscoreformat.osfpvg+xml',
        '.saf': 'application/vnd.yamaha.smaf-audio',
        '.spf': 'application/vnd.yamaha.smaf-phrase',
        '.cmp': 'application/vnd.yellowriver-custom-menu',
        '.zir': 'application/vnd.zul',
        '.zirz': 'application/vnd.zul',
        '.zaz': 'application/vnd.zzazz.deck+xml',
        '.vxml': 'application/voicexml+xml',
        '.wgt': 'application/widget',
        '.hlp': 'application/winhlp',
        '.wsdl': 'application/wsdl+xml',
        '.wspolicy': 'application/wspolicy+xml',
        '.7z': 'application/x-7z-compressed',
        '.abw': 'application/x-abiword',
        '.ace': 'application/x-ace-compressed',
        '.arj': 'application/x-arj',
        '.vox': 'application/x-authorware-bin',
        '.u32': 'application/x-authorware-bin',
        '.aab': 'application/x-authorware-bin',
        '.x32': 'application/x-authorware-bin',
        '.aam': 'application/x-authorware-map',
        '.aas': 'application/x-authorware-seg',
        '.bcpio': 'application/x-bcpio',
        '.torrent': 'application/x-bittorrent',
        '.blb': 'application/x-blorb',
        '.blorb': 'application/x-blorb',
        '.bz': 'application/x-bzip',
        '.boz': 'application/x-bzip2',
        '.bz2': 'application/x-bzip2',
        '.cb7': 'application/x-cbr',
        '.cbr': 'application/x-cbr',
        '.cbz': 'application/x-cbr',
        '.cba': 'application/x-cbr',
        '.cbt': 'application/x-cbr',
        '.vcd': 'application/x-cdlink',
        '.cfs': 'application/x-cfs-compressed',
        '.chat': 'application/x-chat',
        '.pgn': 'application/x-chess-pgn',
        '.crx': 'application/x-chrome-extension',
        '.cco': 'application/x-cocoa',
        '.nsc': 'application/x-conference',
        '.cpio': 'application/x-cpio',
        '.csh': 'application/x-csh',
        '.udeb': 'application/x-debian-package',
        '.dgc': 'application/x-dgc-compressed',
        '.dir': 'application/x-director',
        '.swa': 'application/x-director',
        '.w3d': 'application/x-director',
        '.fgd': 'application/x-director',
        '.cst': 'application/x-director',
        '.dxr': 'application/x-director',
        '.cct': 'application/x-director',
        '.cxt': 'application/x-director',
        '.dcr': 'application/x-director',
        '.wad': 'application/x-doom',
        '.ncx': 'application/x-dtbncx+xml',
        '.dtb': 'application/x-dtbook+xml',
        '.res': 'application/x-dtbresource+xml',
        '.dvi': 'application/x-dvi',
        '.evy': 'application/x-envoy',
        '.eva': 'application/x-eva',
        '.bdf': 'application/x-font-bdf',
        '.gsf': 'application/x-font-ghostscript',
        '.psf': 'application/x-font-linux-psf',
        '.otf': 'font/otf',
        '.pcf': 'application/x-font-pcf',
        '.snf': 'application/x-font-snf',
        '.ttc': 'font/collection',
        '.ttf': 'font/ttf',
        '.pfm': 'application/x-font-type1',
        '.pfa': 'application/x-font-type1',
        '.pfb': 'application/x-font-type1',
        '.afm': 'application/x-font-type1',
        '.arc': 'application/x-freearc',
        '.spl': 'application/x-futuresplash',
        '.gca': 'application/x-gca-compressed',
        '.ulx': 'application/x-glulx',
        '.gnumeric': 'application/x-gnumeric',
        '.gramps': 'application/x-gramps-xml',
        '.gtar': 'application/x-gtar',
        '.hdf': 'application/x-hdf',
        '.php': 'application/x-httpd-php',
        '.install': 'application/x-install-instructions',
        '.jardiff': 'application/x-java-archive-diff',
        '.jnlp': 'application/x-java-jnlp-file',
        '.latex': 'application/x-latex',
        '.luac': 'application/x-lua-bytecode',
        '.lzh': 'application/x-lzh-compressed',
        '.lha': 'application/x-lzh-compressed',
        '.run': 'application/x-makeself',
        '.mie': 'application/x-mie',
        '.mobi': 'application/x-mobipocket-ebook',
        '.prc': 'application/x-pilot',
        '.application': 'application/x-ms-application',
        '.lnk': 'application/x-ms-shortcut',
        '.wmd': 'application/x-ms-wmd',
        '.wmz': 'application/x-msmetafile',
        '.xbap': 'application/x-ms-xbap',
        '.mdb': 'application/x-msaccess',
        '.obd': 'application/x-msbinder',
        '.crd': 'application/x-mscardfile',
        '.clp': 'application/x-msclip',
        '.com': 'application/x-msdownload',
        '.bat': 'application/x-msdownload',
        '.m13': 'application/x-msmediaview',
        '.mvb': 'application/x-msmediaview',
        '.m14': 'application/x-msmediaview',
        '.wmf': 'application/x-msmetafile',
        '.emf': 'application/x-msmetafile',
        '.emz': 'application/x-msmetafile',
        '.mny': 'application/x-msmoney',
        '.pub': 'application/x-mspublisher',
        '.scd': 'application/x-msschedule',
        '.trm': 'application/x-msterminal',
        '.wri': 'application/x-mswrite',
        '.cdf': 'application/x-netcdf',
        '.nc': 'application/x-netcdf',
        '.pac': 'application/x-ns-proxy-autoconfig',
        '.nzb': 'application/x-nzb',
        '.pl': 'application/x-perl',
        '.pm': 'application/x-perl',
        '.pfx': 'application/x-pkcs12',
        '.p12': 'application/x-pkcs12',
        '.p7b': 'application/x-pkcs7-certificates',
        '.spc': 'application/x-pkcs7-certificates',
        '.p7r': 'application/x-pkcs7-certreqresp',
        '.rar': 'application/x-rar-compressed',
        '.rpm': 'application/x-redhat-package-manager',
        '.ris': 'application/x-research-info-systems',
        '.sea': 'application/x-sea',
        '.sh': 'application/x-sh',
        '.shar': 'application/x-shar',
        '.swf': 'application/x-shockwave-flash',
        '.xap': 'application/x-silverlight-app',
        '.sql': 'application/x-sql',
        '.sit': 'application/x-stuffit',
        '.sitx': 'application/x-stuffitx',
        '.srt': 'application/x-subrip',
        '.sv4cpio': 'application/x-sv4cpio',
        '.sv4crc': 'application/x-sv4crc',
        '.t3': 'application/x-t3vm-image',
        '.gam': 'application/x-tads',
        '.tar': 'application/x-tar',
        '.tcl': 'application/x-tcl',
        '.tk': 'application/x-tcl',
        '.tex': 'application/x-tex',
        '.tfm': 'application/x-tex-tfm',
        '.texinfo': 'application/x-texinfo',
        '.texi': 'application/x-texinfo',
        '.obj': 'application/x-tgif',
        '.ustar': 'application/x-ustar',
        '.hdd': 'application/x-virtualbox-hdd',
        '.ova': 'application/x-virtualbox-ova',
        '.ovf': 'application/x-virtualbox-ovf',
        '.vbox': 'application/x-virtualbox-vbox',
        '.vbox-extpack': 'application/x-virtualbox-vbox-extpack',
        '.vdi': 'application/x-virtualbox-vdi',
        '.vhd': 'application/x-virtualbox-vhd',
        '.vmdk': 'application/x-virtualbox-vmdk',
        '.src': 'application/x-wais-source',
        '.webapp': 'application/x-web-app-manifest+json',
        '.pem': 'application/x-x509-ca-cert',
        '.der': 'application/x-x509-ca-cert',
        '.crt': 'application/x-x509-ca-cert',
        '.fig': 'application/x-xfig',
        '.xlf': 'application/x-xliff+xml',
        '.xpi': 'application/x-xpinstall',
        '.xz': 'application/x-xz',
        '.z3': 'application/x-zmachine',
        '.z4': 'application/x-zmachine',
        '.z6': 'application/x-zmachine',
        '.z1': 'application/x-zmachine',
        '.z8': 'application/x-zmachine',
        '.z7': 'application/x-zmachine',
        '.z2': 'application/x-zmachine',
        '.z5': 'application/x-zmachine',
        '.xaml': 'application/xaml+xml',
        '.xdf': 'application/xcap-diff+xml',
        '.xenc': 'application/xenc+xml',
        '.xhtml': 'application/xhtml+xml',
        '.xht': 'application/xhtml+xml',
        '.xsl': 'application/xml',
        '.rng': 'application/xml',
        '.xml': 'text/xml',
        '.xsd': 'application/xml',
        '.dtd': 'application/xml-dtd',
        '.xop': 'application/xop+xml',
        '.xpl': 'application/xproc+xml',
        '.xslt': 'application/xslt+xml',
        '.xspf': 'application/xspf+xml',
        '.mxml': 'application/xv+xml',
        '.xvml': 'application/xv+xml',
        '.xhvml': 'application/xv+xml',
        '.xvm': 'application/xv+xml',
        '.yang': 'application/yang',
        '.yin': 'application/yin+xml',
        '.zip': 'application/zip',
        '.3gpp': 'video/3gpp',
        '.adp': 'audio/adpcm',
        '.snd': 'audio/basic',
        '.au': 'audio/basic',
        '.kar': 'audio/midi',
        '.midi': 'audio/midi',
        '.mid': 'audio/midi',
        '.rmi': 'audio/midi',
        '.mp3': 'audio/mpeg',
        '.mp4a': 'audio/mp4',
        '.m4a': 'audio/x-m4a',
        '.mp2': 'audio/mpeg',
        '.m3a': 'audio/mpeg',
        '.mp2a': 'audio/mpeg',
        '.mpga': 'audio/mpeg',
        '.m2a': 'audio/mpeg',
        '.oga': 'audio/ogg',
        '.spx': 'audio/ogg',
        '.ogg': 'audio/ogg',
        '.opus': 'audio/ogg',
        '.s3m': 'audio/s3m',
        '.sil': 'audio/silk',
        '.uva': 'audio/vnd.dece.audio',
        '.uvva': 'audio/vnd.dece.audio',
        '.eol': 'audio/vnd.digital-winds',
        '.dra': 'audio/vnd.dra',
        '.dts': 'audio/vnd.dts',
        '.dtshd': 'audio/vnd.dts.hd',
        '.lvp': 'audio/vnd.lucent.voice',
        '.pya': 'audio/vnd.ms-playready.media.pya',
        '.ecelp4800': 'audio/vnd.nuera.ecelp4800',
        '.ecelp7470': 'audio/vnd.nuera.ecelp7470',
        '.ecelp9600': 'audio/vnd.nuera.ecelp9600',
        '.rip': 'audio/vnd.rip',
        '.wav': 'audio/x-wav',
        '.weba': 'audio/webm',
        '.aac': 'audio/x-aac',
        '.aifc': 'audio/x-aiff',
        '.aiff': 'audio/x-aiff',
        '.aif': 'audio/x-aiff',
        '.caf': 'audio/x-caf',
        '.flac': 'audio/x-flac',
        '.mka': 'audio/x-matroska',
        '.m3u': 'audio/x-mpegurl',
        '.wax': 'audio/x-ms-wax',
        '.wma': 'audio/x-ms-wma',
        '.ra': 'audio/x-realaudio',
        '.ram': 'audio/x-pn-realaudio',
        '.rmp': 'audio/x-pn-realaudio-plugin',
        '.xm': 'audio/xm',
        '.cdx': 'chemical/x-cdx',
        '.cif': 'chemical/x-cif',
        '.cmdf': 'chemical/x-cmdf',
        '.cml': 'chemical/x-cml',
        '.csml': 'chemical/x-csml',
        '.xyz': 'chemical/x-xyz',
        '.apng': 'image/apng',
        '.bmp': 'image/x-ms-bmp',
        '.cgm': 'image/cgm',
        '.g3': 'image/g3fax',
        '.gif': 'image/gif',
        '.ief': 'image/ief',
        '.jpeg': 'image/jpeg',
        '.jpe': 'image/jpeg',
        '.jpg': 'image/jpeg',
        '.ktx': 'image/ktx',
        '.png': 'image/png',
        '.btif': 'image/prs.btif',
        '.sgi': 'image/sgi',
        '.svgz': 'image/svg+xml',
        '.svg': 'image/svg+xml',
        '.tif': 'image/tiff',
        '.tiff': 'image/tiff',
        '.psd': 'image/vnd.adobe.photoshop',
        '.uvvi': 'image/vnd.dece.graphic',
        '.uvi': 'image/vnd.dece.graphic',
        '.uvg': 'image/vnd.dece.graphic',
        '.uvvg': 'image/vnd.dece.graphic',
        '.djv': 'image/vnd.djvu',
        '.djvu': 'image/vnd.djvu',
        '.sub': 'text/vnd.dvb.subtitle',
        '.dwg': 'image/vnd.dwg',
        '.dxf': 'image/vnd.dxf',
        '.fbs': 'image/vnd.fastbidsheet',
        '.fpx': 'image/vnd.fpx',
        '.fst': 'image/vnd.fst',
        '.mmr': 'image/vnd.fujixerox.edmics-mmr',
        '.rlc': 'image/vnd.fujixerox.edmics-rlc',
        '.mdi': 'image/vnd.ms-modi',
        '.wdp': 'image/vnd.ms-photo',
        '.npx': 'image/vnd.net-fpx',
        '.wbmp': 'image/vnd.wap.wbmp',
        '.xif': 'image/vnd.xiff',
        '.webp': 'image/webp',
        '.3ds': 'image/x-3ds',
        '.ras': 'image/x-cmu-raster',
        '.cmx': 'image/x-cmx',
        '.fhc': 'image/x-freehand',
        '.fh7': 'image/x-freehand',
        '.fh5': 'image/x-freehand',
        '.fh': 'image/x-freehand',
        '.fh4': 'image/x-freehand',
        '.ico': 'image/x-icon',
        '.jng': 'image/x-jng',
        '.sid': 'image/x-mrsid-image',
        '.pcx': 'image/x-pcx',
        '.pic': 'image/x-pict',
        '.pct': 'image/x-pict',
        '.pnm': 'image/x-portable-anymap',
        '.pbm': 'image/x-portable-bitmap',
        '.pgm': 'image/x-portable-graymap',
        '.ppm': 'image/x-portable-pixmap',
        '.rgb': 'image/x-rgb',
        '.tga': 'image/x-tga',
        '.xbm': 'image/x-xbitmap',
        '.xpm': 'image/x-xpixmap',
        '.xwd': 'image/x-xwindowdump',
        '.eml': 'message/rfc822',
        '.mime': 'message/rfc822',
        '.gltf': 'model/gltf+json',
        '.glb': 'model/gltf-binary',
        '.iges': 'model/iges',
        '.igs': 'model/iges',
        '.silo': 'model/mesh',
        '.mesh': 'model/mesh',
        '.msh': 'model/mesh',
        '.dae': 'model/vnd.collada+xml',
        '.dwf': 'model/vnd.dwf',
        '.gdl': 'model/vnd.gdl',
        '.gtw': 'model/vnd.gtw',
        '.mts': 'model/vnd.mts',
        '.vtu': 'model/vnd.vtu',
        '.vrml': 'model/vrml',
        '.wrl': 'model/vrml',
        '.x3db': 'model/x3d+binary',
        '.x3dbz': 'model/x3d+binary',
        '.x3dvz': 'model/x3d+vrml',
        '.x3dv': 'model/x3d+vrml',
        '.x3d': 'model/x3d+xml',
        '.x3dz': 'model/x3d+xml',
        '.appcache': 'text/cache-manifest',
        '.manifest': 'text/cache-manifest',
        '.ics': 'text/calendar',
        '.ifb': 'text/calendar',
        '.litcoffee': 'text/coffeescript',
        '.coffee': 'text/coffeescript',
        '.css': 'text/css',
        '.csv': 'text/csv',
        '.hjson': 'text/hjson',
        '.htm': 'text/html',
        '.html': 'text/html',
        '.shtml': 'text/html',
        '.jade': 'text/jade',
        '.jsx': 'text/jsx',
        '.less': 'text/less',
        '.md': 'text/markdown',
        '.markdown': 'text/markdown',
        '.mml': 'text/mathml',
        '.n3': 'text/n3',
        '.text': 'text/plain',
        '.conf': 'text/plain',
        '.list': 'text/plain',
        '.txt': 'text/plain',
        '.in': 'text/plain',
        '.ini': 'text/plain',
        '.log': 'text/plain',
        '.def': 'text/plain',
        '.dsc': 'text/prs.lines.tag',
        '.rtx': 'text/richtext',
        '.sgml': 'text/sgml',
        '.sgm': 'text/sgml',
        '.slm': 'text/slim',
        '.slim': 'text/slim',
        '.stylus': 'text/stylus',
        '.styl': 'text/stylus',
        '.tsv': 'text/tab-separated-values',
        '.me': 'text/troff',
        '.man': 'text/troff',
        '.tr': 'text/troff',
        '.t': 'text/troff',
        '.ms': 'text/troff',
        '.roff': 'text/troff',
        '.ttl': 'text/turtle',
        '.uris': 'text/uri-list',
        '.uri': 'text/uri-list',
        '.urls': 'text/uri-list',
        '.vcard': 'text/vcard',
        '.curl': 'text/vnd.curl',
        '.dcurl': 'text/vnd.curl.dcurl',
        '.mcurl': 'text/vnd.curl.mcurl',
        '.scurl': 'text/vnd.curl.scurl',
        '.fly': 'text/vnd.fly',
        '.flx': 'text/vnd.fmi.flexstor',
        '.gv': 'text/vnd.graphviz',
        '.3dml': 'text/vnd.in3d.3dml',
        '.spot': 'text/vnd.in3d.spot',
        '.jad': 'text/vnd.sun.j2me.app-descriptor',
        '.wml': 'text/vnd.wap.wml',
        '.wmls': 'text/vnd.wap.wmlscript',
        '.vtt': 'text/vtt',
        '.s': 'text/x-asm',
        '.asm': 'text/x-asm',
        '.cc': 'text/x-c',
        '.dic': 'text/x-c',
        '.cpp': 'text/x-c',
        '.h': 'text/x-c',
        '.c': 'text/x-c',
        '.cxx': 'text/x-c',
        '.hh': 'text/x-c',
        '.htc': 'text/x-component',
        '.f77': 'text/x-fortran',
        '.f90': 'text/x-fortran',
        '.f': 'text/x-fortran',
        '.for': 'text/x-fortran',
        '.hbs': 'text/x-handlebars-template',
        '.java': 'text/x-java-source',
        '.lua': 'text/x-lua',
        '.mkd': 'text/x-markdown',
        '.nfo': 'text/x-nfo',
        '.opml': 'text/x-opml',
        '.p': 'text/x-pascal',
        '.pas': 'text/x-pascal',
        '.pde': 'text/x-processing',
        '.sass': 'text/x-sass',
        '.scss': 'text/x-scss',
        '.etx': 'text/x-setext',
        '.sfv': 'text/x-sfv',
        '.ymp': 'text/x-suse-ymp',
        '.uu': 'text/x-uuencode',
        '.vcs': 'text/x-vcalendar',
        '.vcf': 'text/x-vcard',
        '.yaml': 'text/yaml',
        '.yml': 'text/yaml',
        '.3gp': 'video/3gpp',
        '.3g2': 'video/3gpp2',
        '.h261': 'video/h261',
        '.h263': 'video/h263',
        '.h264': 'video/h264',
        '.jpgv': 'video/jpeg',
        '.jpgm': 'video/jpm',
        '.jpm': 'video/jpm',
        '.mj2': 'video/mj2',
        '.mjp2': 'video/mj2',
        '.ts': 'video/mp2t',
        '.mp4v': 'video/mp4',
        '.mp4': 'video/mp4',
        '.mpg4': 'video/mp4',
        '.m1v': 'video/mpeg',
        '.mpg': 'video/mpeg',
        '.mpeg': 'video/mpeg',
        '.m2v': 'video/mpeg',
        '.mpe': 'video/mpeg',
        '.ogv': 'video/ogg',
        '.qt': 'video/quicktime',
        '.mov': 'video/quicktime',
        '.uvh': 'video/vnd.dece.hd',
        '.uvvh': 'video/vnd.dece.hd',
        '.uvvm': 'video/vnd.dece.mobile',
        '.uvm': 'video/vnd.dece.mobile',
        '.uvvp': 'video/vnd.dece.pd',
        '.uvp': 'video/vnd.dece.pd',
        '.uvs': 'video/vnd.dece.sd',
        '.uvvs': 'video/vnd.dece.sd',
        '.uvvv': 'video/vnd.dece.video',
        '.uvv': 'video/vnd.dece.video',
        '.dvb': 'video/vnd.dvb.file',
        '.fvt': 'video/vnd.fvt',
        '.mxu': 'video/vnd.mpegurl',
        '.m4u': 'video/vnd.mpegurl',
        '.pyv': 'video/vnd.ms-playready.media.pyv',
        '.uvvu': 'video/vnd.uvvu.mp4',
        '.uvu': 'video/vnd.uvvu.mp4',
        '.viv': 'video/vnd.vivo',
        '.webm': 'video/webm',
        '.f4v': 'video/x-f4v',
        '.fli': 'video/x-fli',
        '.flv': 'video/x-flv',
        '.m4v': 'video/x-m4v',
        '.mks': 'video/x-matroska',
        '.mkv': 'video/x-matroska',
        '.mk3d': 'video/x-matroska',
        '.mng': 'video/x-mng',
        '.asf': 'video/x-ms-asf',
        '.asx': 'video/x-ms-asf',
        '.vob': 'video/x-ms-vob',
        '.wm': 'video/x-ms-wm',
        '.wmv': 'video/x-ms-wmv',
        '.wmx': 'video/x-ms-wmx',
        '.wvx': 'video/x-ms-wvx',
        '.avi': 'video/x-msvideo',
        '.movie': 'video/x-sgi-movie',
        '.smv': 'video/x-smv',
        '.ice': 'x-conference/x-cooltalk'
    }


    def toList(
        val: Any
    ) -> list[Any]:
        if isinstance(val, list):
            return val
        elif val is None:
            return []
        else:
            return [val]


    def toSet(
        val: Any
    ) -> set[Any]:
        return set(toList(val))


    class Settings:
        @staticmethod
        def __get_credentials(
            creds: dict[str, Any]
        ) -> Tuple[str, str] | None:
            if creds.get('credential'):
                password = demisto.get(creds, 'credentials.password')
                if username := demisto.get(creds, 'credentials.user'):
                    return username, (password or '')
            elif username := creds.get('identifier'):
                return username, (creds.get('password') or '')
            return None

        @staticmethod
        def __to_timezone_offset(
            val: str | None
        ) -> int:
            if val is None:
                return 0
            elif m := re.fullmatch(r'^([+-])(\d\d):?(\d\d)$', str(val)):
                tz = (int(m[2]) * 60) + int(m[3])
                return -tz if m[1] == '-' else tz
            else:
                raise DemistoException(f'Invalid timezone - {val}')

        @staticmethod
        def __parse_human_size(
            size: str | int,
            error_prefix: str | None,
        ) -> int:
            """ Parse a human readable size string

            :param size: The human readable size.
            :param error_prefix: The prefix text for error messages.
            :return: Size in bytes
            """
            if isinstance(size, int):
                return size
            elif not (m := re.fullmatch(r'\s*(\d+(?:\.\d+)?)\s*([KMGT]?B)?\s*', size.upper())):
                error_prefix = error_prefix or ''
                raise DemistoException(f'{error_prefix} - {size}')

            num, unit = m.groups()
            UNITS = {None: 1, 'B': 1, 'KB': 2**10, 'MB': 2**20, 'GB': 2**30, 'TB': 2**40}
            return int(float(num) * UNITS[unit])

        @staticmethod
        def __parse_human_rate(
            rate: str | int | float,
            error_prefix: str | None,
        ) -> float:
            """ Parse a human readable rate string

            :param size: The human readable rate string.
            :param error_prefix: The prefix text for error messages.
            :return: Rate in Mbps
            """
            if isinstance(rate, (int, float)):
                return float(rate)
            elif not (m := re.fullmatch(r'\s*(\d+(?:\.\d+)?)\s*([KMG]?[bB]ps)?\s*', rate)):
                error_prefix = error_prefix or ''
                raise DemistoException(f'{error_prefix} - {rate}')

            num, unit = m.groups()
            UNITS = {
                None: 1,
                'bps': 2**-20, 'Kbps': 2**-10, 'Mbps': 1, 'Gbps': 2**10,
                'Bps': 2**-17, 'KBps': 2**-7, 'MBps': 2**-3, 'GBps': 2**7,
            }
            return float(num) * UNITS[unit]

        @staticmethod
        def __parse_preferred_syslog_headers(
            config: str | None,
        ) -> dict[str, str]:
            preferred_config = {}
            for x in argToList(config):
                product, syslog_header_format = x.split('=', maxsplit=1)
                preferred_config[product.strip()] = syslog_header_format.strip().replace('_', ' ')
            return preferred_config

        @staticmethod
        def __make_syslog_pri(
            facility: str,
            severity: str,
        ) -> int:
            facility = {
                'kern': 0,
                'user': 1,
                'mail': 2,
                'daemon':3,
                'auth': 4,
                'syslog': 5,
                'lpr': 6,
                'news': 7,
                'uucp': 8,
                'cron': 9,
                'authpriv': 10,
                'ftp': 11,
                'local0': 16,
                'local1': 17,
                'local2': 18,
                'local3': 19,
                'local4': 20,
                'local5': 21,
                'local6': 22,
                'local7': 23,
            }.get(facility) or 0

            severity = {
                'emerg': 0,
                'alert': 1,
                'crit': 2,
                'err': 3,
                'warning': 4,
                'notice': 5,
                'info': 6,
                'debug': 7
            }.get(severity) or 0

            return facility * 8 + severity

        def __init__(
            self,
            params: dict[str, Any]
        ) -> None:
            params = assign_params(**params)
            self.__params = params
            self.__socket_timeout = DEFAULT_SOCKET_TIMEOUT

            ''' SECTION: Connect '''
            self.__proxies, self.__insecure = handle_proxy_for_long_running(proxy_param_name='proxy')
            rate = Settings.__parse_human_rate(
                params.get('rate_limit') or 0,
                'Invalid rate limit'
            )
            self.__rate_limit = max(rate, 0.0)

            ''' SECTION: Miscellaneous '''
            self.__tz_offset_display = Settings.__to_timezone_offset(
                params.get('timezone_display')
            )
            self.__tz_offset_logging = Settings.__to_timezone_offset(
                params.get('timezone_logging')
            )
            self.__enable_alert_creation = argToBoolean(
                params.get('enable_alert_creation', 'false')
            )

            ''' SECTION: XSIAM HTTP Collector '''
            self.__xsiam_hc_enable = argToBoolean(params.get('xsiam_hc_enable', 'true'))
            if xsiam_api_url := params.get('xsiam_api_url') or None:
                url_comps = urllib.parse.urlparse(xsiam_api_url)
                xsiam_api_url = urllib.parse.urlunparse(
                    namedtuple('UrlComps', ['scheme', 'netloc', 'path', 'params', 'query', 'fragment'])(
                        url_comps.scheme, url_comps.netloc, '/', '', '', ''
                    )
                )
            self.__xsiam_api_url = xsiam_api_url
            self.__xsiam_hc_api_key_raw = params.get('xsiam_hc_api_key_raw') or None
            self.__xsiam_hc_api_key_cef = params.get('xsiam_hc_api_key_cef') or None
            self.__xsiam_hc_compression = argToBoolean(params.get('xsiam_hc_compression', True))
            self.__xsiam_hc_transportation_format = params.get('xsiam_hc_transportation_format')
            self.__xsiam_hc_enforce_log_spec_syslog_format = params.get('xsiam_hc_enforce_log_spec_syslog_format') or None
            self.__xsiam_hc_raw_log_to_cef = argToBoolean(params.get('xsiam_hc_raw_log_to_cef', 'true'))
            size = Settings.__parse_human_size(
                params.get('xsiam_hc_buffer_size') or DEFAULT_HEC_UPLOAD_BUFFER_SIZE,
                'Invalid upload buffer size'
            )
            self.__xsiam_hc_buffer_size = min(max(0, size), MAX_HEC_UPLOAD_BUFFER_SIZE)

            ''' SECTION: Syslog Collector '''
            self.__syslog_transport_enable = argToBoolean(params.get('syslog_transport_enable', 'false'))
            if addr := params.get('syslog_transport_address'):
                if m := re.fullmatch(r'(?P<host>[^:]+)(?::(?P<port>\d+))?', addr.strip()):
                    host = m['host']
                    port = int(m['port'] or 514)
                    if port > 65535:
                        raise DemistoException(f'Invalid port number of the syslog address - {port}')
                    self.__syslog_transport_address = (host, port)
                else:
                    raise DemistoException(f'Invalid syslog address - {addr}')
            else:
                self.__syslog_transport_address = None

            self.__syslog_transport_protocol = params.get('syslog_transport_protocol') or 'UDP'
            self.__syslog_transport_format = params.get('syslog_transport_format') or SyslogHeaderType.RFC_5424
            self.__syslog_transport_enforce_log_spec_format = params.get('syslog_transport_enforce_log_spec_format') or None

            ''' SECTION: Default Scenario '''
            self.__default_scenario_list = argToList(params.get('default_scenario_list'))
            self.__default_scenario_internal_tap_products = \
                argToList(params.get('default_scenario_internal_tap_products'))
            self.__default_scenario_internal_proxy_squid_log_formats = \
                argToList(params.get('default_scenario_internal_proxy_squid_log_formats'))
            self.__default_scenario_internal_web_apache_log_formats = \
                argToList(params.get('default_scenario_internal_web_apache_log_formats'))
            self.__default_scenario_external_tap_products = \
                argToList(params.get('default_scenario_external_tap_products'))
            self.__default_scenario_external_proxy_products = \
                argToList(params.get('default_scenario_external_proxy_products'))

            ''' SECTION: Custom Scenario '''
            self.__custom_scenario_enable = argToBoolean(params.get('custom_scenario_enable', 'false'))
            self.__custom_scenario_json = params.get('custom_scenario_json') or None
            self.__custom_scenario_url = params.get('custom_scenario_url') or None
            self.__custom_scenario_url_creds = Settings.__get_credentials(params.get('custom_scenario_url_creds') or {})
            self.__custom_scenario_url_zip_password = params.get('custom_scenario_url_zip_password') or None

            ''' SECTION: Scenario '''
            self.__scenario_enable_resume_scheduled_jobs = argToBoolean(params.get('scenario_enable_resume_scheduled_jobs', 'true'))
            self.__scenario_run_mode = params.get('scenario_run_mode') or 'random'
            self.__scenario_sources_loop = params.get('scenario_sources_loop')
            if self.__scenario_sources_loop is not None:
                self.__scenario_sources_loop = max(int(self.__scenario_sources_loop), 0)

            self.__scenario_jobs_loop = params.get('scenario_jobs_loop')
            if self.__scenario_jobs_loop is not None:
                self.__scenario_jobs_loop = max(int(self.__scenario_jobs_loop), 0)

            ''' SECTION: Syslog Format '''
            self.__syslog_preferred_headers = Settings.__parse_preferred_syslog_headers(
                params.get('syslog_preferred_headers')
            )
            self.__syslog_header_pri = Settings.__make_syslog_pri(
                params.get('syslog_facility') or 'local0',
                params.get('syslog_severity') or 'info',
            )

        @property
        def insecure(
            self,
        ) -> bool:
            return self.__insecure

        @property
        def proxies(
            self,
        ) -> dict[str, str]:
            return self.__proxies

        @property
        def tz_offset_display(
            self,
        ) -> int:
            return self.__tz_offset_display

        @property
        def tz_offset_logging(
            self,
        ) -> int:
            return self.__tz_offset_logging

        @property
        def enable_alert_creation(
            self,
        ) -> bool:
            return self.__enable_alert_creation

        @property
        def socket_timeout(
            self,
        ) -> int:
            return self.__socket_timeout

        @property
        def rate_limit(
            self,
        ) -> float:
            return self.__rate_limit

        @property
        def xsiam_hc_enable(
            self,
        ) -> bool:
            return self.__xsiam_hc_enable

        @property
        def xsiam_api_url(
            self,
        ) -> str | None:
            return self.__xsiam_api_url

        @property
        def xsiam_hc_api_key_raw(
            self,
        ) -> str | None:
            return self.__xsiam_hc_api_key_raw

        @property
        def xsiam_hc_api_key_cef(
            self,
        ) -> str | None:
            return self.__xsiam_hc_api_key_cef

        @property
        def xsiam_hc_compression(
            self,
        ) -> bool:
            return self.__xsiam_hc_compression

        @property
        def xsiam_hc_transportation_format(
            self,
        ) -> str | None:
            return self.__xsiam_hc_transportation_format

        @property
        def xsiam_hc_enforce_log_spec_syslog_format(
            self,
        ) -> str | None:
            return self.__xsiam_hc_enforce_log_spec_syslog_format

        @property
        def xsiam_hc_raw_log_to_cef(
            self,
        ) -> bool:
            return self.__xsiam_hc_raw_log_to_cef

        @property
        def xsiam_hc_buffer_size(
            self,
        ) -> bool:
            return self.__xsiam_hc_buffer_size

        @property
        def syslog_transport_enable(
            self,
        ) -> bool:
            return self.__syslog_transport_enable

        @property
        def syslog_transport_address(
            self,
        ) -> Tuple[str, int] | None:
            return self.__syslog_transport_address

        @property
        def syslog_transport_protocol(
            self,
        ) -> str:
            return self.__syslog_transport_protocol

        @property
        def syslog_transport_format(
            self,
        ) -> str:
            return self.__syslog_transport_format

        @property
        def syslog_transport_enforce_log_spec_format(
            self,
        ) -> str | None:
            return self.__syslog_transport_enforce_log_spec_format

        @property
        def scenario_enable_resume_scheduled_jobs(
            self,
        ) -> bool:
            return self.__scenario_enable_resume_scheduled_jobs

        @property
        def scenario_run_mode(
            self,
        ) -> str:
            return self.__scenario_run_mode

        @property
        def scenario_sources_loop(
            self,
        ) -> int | None:
            return self.__scenario_sources_loop

        @property
        def scenario_jobs_loop(
            self,
        ) -> int | None:
            return self.__scenario_jobs_loop

        @property
        def default_scenario_list(
            self,
        ) -> list[str]:
            return self.__default_scenario_list

        @property
        def default_scenario_internal_tap_products(
            self,
        ) -> list[str]:
            return self.__default_scenario_internal_tap_products

        @property
        def default_scenario_internal_proxy_squid_log_formats(
            self,
        ) -> list[str]:
            return self.__default_scenario_internal_proxy_squid_log_formats

        @property
        def default_scenario_internal_web_apache_log_formats(
            self,
        ) -> list[str]:
            return self.__default_scenario_internal_web_apache_log_formats

        @property
        def default_scenario_external_tap_products(
            self,
        ) -> list[str]:
            return self.__default_scenario_external_tap_products

        @property
        def default_scenario_external_proxy_products(
            self,
        ) -> list[str]:
            return self.__default_scenario_external_proxy_products

        @property
        def custom_scenario_enable(
            self,
        ) -> bool:
            return self.__custom_scenario_enable

        @property
        def custom_scenario_json(
            self,
        ) -> str | None:
            return self.__custom_scenario_json

        @property
        def custom_scenario_url(
            self,
        ) -> str | None:
            return self.__custom_scenario_url

        @property
        def custom_scenario_url_creds(
            self,
        ) -> Tuple[str, str] | None:
            return self.__custom_scenario_url_creds

        @property
        def custom_scenario_url_zip_password(
            self,
        ) -> str | None:
            return self.__custom_scenario_url_zip_password

        @property
        def syslog_preferred_headers(
            self,
        ) -> dict[str, str]:
            return self.__syslog_preferred_headers

        @property
        def syslog_header_pri(
            self,
        ) -> int:
            return self.__syslog_header_pri

        def log_now(
            self,
        ) -> datetime.datetime:
            return datetime.datetime.now(datetime.UTC).astimezone(
                datetime.timezone(
                    datetime.timedelta(
                        hours=int(self.__tz_offset_logging / 60),
                        minutes=int(self.__tz_offset_logging % 60)
                    ),
                    ''
                )
            )

        def log_now2(
            self,
        ) -> Tuple[datetime.datetime, datetime.datetime]:
            """ Get the current time in UTC and in the timezone configured

            :return: The current time in UTC and in the timezone configured
            """
            utcnow = datetime.datetime.now(datetime.UTC)
            tznow = utcnow.astimezone(
                datetime.timezone(
                    datetime.timedelta(
                        hours=int(self.__tz_offset_logging / 60),
                        minutes=int(self.__tz_offset_logging % 60)
                    ),
                    ''
                )
            )
            return utcnow, tznow


    def utc_timestamp(
    ) -> float:
        """ Get the current timestamp in UTC.

        :return: The current timestamp time in UTC.
        """
        return datetime.datetime.now(datetime.UTC).timestamp()


    def format_timestamp_to_display(
        timestamp: float | None,
        tz_offset: int,
    ) -> str | None:
        """ Format a UTC timestamp to display.

        :param timestamp: A timestamp in UTC.
        :param tz_offset: Time offset in seconds from the UTC time.
        :return: The time string.
        """
        if timestamp is None:
            return None

        return datetime.datetime.fromtimestamp(
            timestamp,
            tz=datetime.timezone.utc
        ).astimezone(
            datetime.timezone(
                datetime.timedelta(
                    hours=int(tz_offset / 60),
                    minutes=tz_offset % 60
                )
            )
        ).strftime('%Y-%m-%d %H:%M:%S %z')


    def format_status_to_display(
        info: dict[str, Any],
        tz_offset: int,
    ) -> dict[str, Any]:
        """ Convert status values to display

        :param info: The status information
        :param tz_offset: Time offset in seconds from the UTC time.
        :return: The information to display.
        """
        ordered_params = {
            'instance_name': None,
            'last_update': 'time',
            'started': 'time',
            'finished': 'time',
            'status': None,
            'message': None,
            'log_stats': 'log_stats',
            'jobs': 'jobs',
        }
        out = {}
        for k, value_type in ordered_params.items():
            if not (v := info.get(k)):
                continue
            if value_type == 'log_stats' and isinstance(v, dict):
                for hec_type in ('raw', 'cef'):
                    if attrs := v.get(f'hec_{hec_type}'):
                        finished = attrs.get('finished')
                        nlogs_queued = int(attrs.get('queued') or 0)
                        nlogs_sent = int(attrs.get('sent') or 0)
                        prefix = '' if finished or nlogs_queued + nlogs_sent == 0 else '> '
                        out[f'Log Stats - HEC {hec_type.upper()} (queued)'] = f'{prefix}{nlogs_queued:,}'
                        out[f'Log Stats - HEC {hec_type.upper()} (sent)'] = f'{prefix}{nlogs_sent:,}'

                if attrs := v.get(f'syslog'):
                    finished = attrs.get('finished')
                    nlogs_sent = int(attrs.get('sent') or 0)
                    prefix = '' if finished or nlogs_sent == 0 else '> '
                    out[f'Log Stats - Syslog'] = f'{prefix}{nlogs_sent:,}'

            elif value_type == 'jobs' and isinstance(v, dict):
                if waiting_jobs := list(filter(lambda x: 'next_time' in x, toList(v.get('waiting')))):
                    next_job = min(waiting_jobs, key=lambda x:x.get('next_time'))
                    out[f'Jobs - Next Job'] = next_job.get('label') or '<NO LABEL>'
                    out[f'Jobs - Next Run'] = format_timestamp_to_display(next_job.get('next_time'), tz_offset)

                if running_jobs := toList(v.get('running')):
                    runnings_label = ', '.join([
                        j.get('label') or '<NO LABEL>'
                        for j in itertools.islice(iter(running_jobs), 3)
                    ])
                    if len(running_jobs) > 3:
                        runnings_label += ', and more'
                    out[f'Jobs - Running'] = runnings_label
            elif value_type == 'time' and isinstance(v, (int, float)):
                out[k] = format_timestamp_to_display(v, tz_offset)
            else:
                out[k] = v
        return out


    def build_markdown(
        title: str,
        table: list[dict[str, Any]] | dict[str, Any],
    ) -> dict[str, Any]:
        """ Build a markdown text from a table.

        :param title: The title of the table.
        :param table: The table.
        :return: The markdown text created.
        """
        md = tableToMarkdown(
            title,
            toList(table),
            headers=table.keys() if isinstance(table, dict) else None,
            headerTransform=lambda name: ' '.join(
                (token.title() if token == token.lower() else token)
                for token in name.replace('_', ' ').split(' ')
            ),
            sort_headers=False,
        )
        if isinstance(table, list) and len(table) == 1:
            return md + '|\n'
        else:
            return md


    def replace_datetime_with_utcnowvar(
        val: Any
    ) -> Any:
        def __replace_datetime_with_utcnowvar(
            val: Any,
            pat: re.Pattern
        ) -> Any:
            def __replace(
                m: re.Match,
            ) -> str:
                val = m[0]
                if m := re.fullmatch(
                    (
                        r'(?:20[0-4]\d|19[7-9]\d)-(?:0[1-9]|1[012])-(?:0[1-9]|[12]\d|3[01])'
                        r'(?P<t>[T ])'
                        r'(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d(?P<fraction>.\d{1,9})?'
                        r'(?P<tz>Z|(?P<tz_leading> )?[+-]\d\d:?\d\d)'
                    ),
                    val
                ):
                    out = "{datetime.datetime.now(datetime.UTC).strftime('%Y-%m-%d" + m["t"] + "%H:%M:%S"
                    if fraction := m['fraction']:
                        if len(fraction) < 6:
                            out += ".%f')[:" + str(len(fraction)) + "]"
                        else:
                            out += ".%f')"
                    else:
                        out += "')"

                    if tz := m['tz']:
                        tz = tz.lstrip()
                        tz_leading = m['tz_leading'] or ''
                        if tz == 'Z':
                            out += f"+'{tz_leading}Z'"
                        elif ':' in tz:
                            out += f"+'{tz_leading}+00:00'"
                        else:
                            out += f"+'{tz_leading}+0000'"
                    out += '}'

                elif m := re.fullmatch(
                    (
                        r'(?:20[0-4]\d|19[7-9]\d)/(?:0[1-9]|1[012])/(?:0[1-9]|[12]\d|3[01])'
                        r'(?P<t>[T ])'
                        r'(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d(?P<fraction>.\d{1,9})?'
                        r'(?P<tz>Z|(?P<tz_leading> )?[+-]\d\d:?\d\d)'
                    ),
                    val
                ):
                    out = "{datetime.datetime.now(datetime.UTC).strftime('%Y/%m/%d" + m["t"] + "%H:%M:%S"
                    if fraction := m['fraction']:
                        if len(fraction) < 6:
                            out += ".%f')[:" + str(len(fraction)) + "]"
                        else:
                            out += ".%f')"
                    else:
                        out += "')"

                    if tz := m['tz']:
                        tz = tz.lstrip()
                        tz_leading = m['tz_leading'] or ''
                        if tz == 'Z':
                            out += f"+'{tz_leading}Z'"
                        elif ':' in tz:
                            out += f"+'{tz_leading}+00:00'"
                        else:
                            out += f"+'{tz_leading}+0000'"
                    out += '}'

                elif m := re.fullmatch(
                    (
                        r'(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)'
                        r' '
                        r'(?:0[1-9]|[12]\d|3[01])'
                        r' '
                        r'(?P<year>(?:20[0-4]\d|19[7-9]\d) )?'
                        r'(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d'
                        r'(?:(?P<tz_leading> )?(?P<tz>GMT|[+-]\d\d:?\d\d))?'
                    ),
                    val
                ):
                    out = "{datetime.datetime.now(datetime.UTC).strftime('%b %d " + ('%Y ' if m['year'] else '') + '%H:%M:%S'
                    if tz := m['tz']:
                        tz_leading = m['tz_leading'] or ''
                        if tz == 'GMT':
                            out += tz_leading + 'GMT'
                        elif ':' in tz:
                            out += tz_leading + '+00:00'
                        else:
                            out += tz_leading + '+0000'
                    out += "')}"

                elif m := re.fullmatch(
                    (
                        r'(?:0[1-9]|[12]\d|3[01])'
                        r'/'
                        r'(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)'
                        r'/'
                        r'(?:20[0-4]\d|19[7-9]\d)'
                        r':'
                        r'(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d'
                        r'(?:(?P<tz_leading> )?(?P<tz>GMT|[+-]\d\d:?\d\d))?'
                    ),
                    val
                ):
                    out = "{datetime.datetime.now(datetime.UTC).strftime('%d/%b/%Y:%H:%M:%S"
                    if tz := m['tz']:
                        tz_leading = m['tz_leading'] or ''
                        if tz == 'GMT':
                            out += tz_leading + 'GMT'
                        elif ':' in tz:
                            out += tz_leading + '+00:00'
                        else:
                            out += tz_leading + '+0000'
                    out += "')}"
                elif m := re.fullmatch(r'(?:1[6-9](?:\d{8}|\d{11}|\d{14}))', val):
                    if len(m[0]) == 10:
                        out = '{int(datetime.datetime.now(datetime.UTC).timestamp())}'
                    elif len(m[0]) == 13:
                        out = '{int(datetime.datetime.now(datetime.UTC).timestamp() * 1000)}'
                    else:
                        out = '{int(datetime.datetime.now(datetime.UTC).timestamp() * 1000000)}'
                else:
                    out = val
                return out

            if isinstance(val, dict):
                return {
                    k: __replace_datetime_with_utcnowvar(v, pat)
                    for k, v in val.items()
                }
            elif isinstance(val, list):
                return [__replace_datetime_with_utcnowvar(v, pat) for v in val]
            elif isinstance(val, str):
                return re.sub(pat, lambda m: __replace(m), val)
            elif isinstance(val, int):
                if 1600000000 <= val <= 1900000000:
                    return '{int(datetime.datetime.now(datetime.UTC).timestamp())}'
                elif 1600000000000 <= val <= 1900000000000:
                    return '{int(datetime.datetime.now(datetime.UTC).timestamp() * 1000)}'
                elif 1600000000000000 <= val <= 1900000000000000:
                    return '{int(datetime.datetime.now(datetime.UTC).timestamp() * 1000000)}'
                else:
                    return val
            else:
                return val

        pattern = re.compile(
            r'\b(?:' + '|'.join(
                [
                    (
                        r'(?:20[0-4]\d|19[7-9]\d)-(?:0[1-9]|1[012])-(?:0[1-9]|[12]\d|3[01])'
                        r'[T ]'
                        r'(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d(?:.\d{1,9})?'
                        r'(?:Z| ?[+-]\d\d:?\d\d)'
                    ),
                    (
                        r'(?:20[0-4]\d|19[7-9]\d)/(?:0[1-9]|1[012])/(?:0[1-9]|[12]\d|3[01])'
                        r'(?:[T ])'
                        r'(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d(?:.\d{1,9})?'
                        r'(?:Z| ?[+-]\d\d:?\d\d)'
                    ),
                    (
                        r'(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)'
                        r' '
                        r'(?:0[1-9]|[12]\d|3[01])'
                        r' '
                        r'(?:(?:20[0-4]\d|19[7-9]\d) )?'
                        r'(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d'
                        r'(?: ?(?:GMT|[+-]\d\d:?\d\d))?'
                    ),
                    (
                        r'(?:0[1-9]|[12]\d|3[01])'
                        r'/'
                        r'(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)'
                        r'/'
                        r'(?:20[0-4]\d|19[7-9]\d)'
                        r':'
                        r'(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d'
                        r'(?: ?(?:GMT|[+-]\d\d:?\d\d))?'
                    ),
                    (
                        r'(?:1[6-9](?:\d{8}|\d{11}|\d{14}))'
                    ),
                ]
            ) + r')\b'
        )
        return __replace_datetime_with_utcnowvar(val, pattern)


    class IntegrationContextUtils:
        """ Integration Context Utilities
        """
        __last_sync: int = 0
        __cache: dict[str, Any] = defaultdict(dict)
        __lock: threading.Lock = threading.Lock()
        __enable_alert_creation: bool = False

        class Status(enum.StrEnum):
            ERROR = enum.auto()
            RUNNING = enum.auto()
            FINISHED = enum.auto()

        @staticmethod
        def __create_incident(
            name: str,
            status: dict[str, Any],
        ) -> None:
            """ Create an incident

            :param name: The name of the incident.
            :param status: The status information.
            """
            def __to_incident_value(
                value: Any
            ) -> Any:
                if isinstance(value, (type(None), bool, int, str, dict, list)):
                    return value
                elif isinstance(value, float):
                    # incident field values doesn't support float
                    return str(value)
                else:
                    return json.dumps(value)

            incident = {
                'name': name,
                'occurred': datetime.datetime.now(datetime.UTC).isoformat(),
                'severity': IncidentSeverity.LOW,
                'details': status.get('message') or '',
                'labels': [
                    {
                        'type': _type,
                        'value': __to_incident_value(value)
                    }
                    for _type, value in status.items()
                ],
                'rawJSON': json.dumps(status),
            }
            demisto.createIncidents([incident])

        @staticmethod
        def load(
        ) -> Tuple[dict[str, Any], int]:
            """ Get the integration context with the current version

            :return: The integration context, with the current version.
            """
            x, version = get_integration_context_with_version()
            return x or {}, version

        @staticmethod
        def save(
            context: dict | None,
            version: int
        ) -> None:
            """ Save the integration context

            :param context: The integration context
            :param version: The version number
            """
            set_integration_context(context, version=version)

        @staticmethod
        def get_status(
        ) -> dict[str, Any]:
            """ Get the status information from the integration context (not the cache).

            :return: The status information.
            """
            x, xversion = IntegrationContextUtils.load()

            info = x.get('status')
            return info if isinstance(info, dict) else {}

        @staticmethod
        def get_last_run(
        ) -> dict[str, Any]:
            x, xversion = IntegrationContextUtils.load()

            info = x.get('last_run')
            return info if isinstance(info, dict) else {}

        @staticmethod
        def get_last_error(
        ) -> dict[str, Any]:
            x, xversion = IntegrationContextUtils.load()

            info = x.get('last_error')
            return info if isinstance(info, dict) else {}

        @classmethod
        def switchCreateAlertMode(
            cls,
            on: bool,
        ) -> None:
            """ Set the alert creation mode.

            :param: on: Set True to turn on the alert creation mode, otherwise False.
            """
            cls.__enable_alert_creation = on

        @classmethod
        def update_status(
            cls,
            info: dict[str, Any],
            new: bool = False,
            sync: bool = False,
        ) -> None:
            """ Update the status information

            :param info: The status information to be merged with the current one.
            :param new: Set True to set info as a new status information, set to False to update the current one.
            :param sync: Set True to write the context to the DB regardless the update interval time, otherwise False.
            """
            now = utc_timestamp()
            with cls.__lock:
                sync = sync or now > cls.__last_sync + DEFAULT_STATUS_UPDATE_INTERVAL
                x = None

                # Update the context
                last_run = None
                if new:
                    if last_run := cls.__cache.get('status'):
                        cls.__cache['last_run'] = last_run
                    else:
                        x, xversion = IntegrationContextUtils.load()
                        if last_run := x.get('status'):
                            cls.__cache['last_run'] = last_run
                            sync = True

                    status = dict(info)
                else:
                    status = cls.__cache['status']
                    status.update(info)

                status['last_update'] = now

                # Remove keys if the given value in 'info' is None
                [status.pop(k, None) for k, v in info.items() if v is None]

                incident = None
                if label := info.get('status'):
                    if label == IntegrationContextUtils.Status.ERROR:
                        cls.__cache['last_error'] = {
                            k: status.get(k)
                            for k in ['last_update', 'started', 'message'] if k in status
                        }
                        if cls.__enable_alert_creation:
                            incident = dict(
                                name=f'{INTEGRATION_NAME} Health Alert - Error',
                                status=dict(status, **{
                                    'instance_name': demisto.integrationInstance(),
                                    'last_run': json.dumps(last_run)
                                })
                            )
                    elif (
                        new and
                        cls.__enable_alert_creation and
                        label != IntegrationContextUtils.Status.FINISHED
                    ):
                        incident = dict(
                            name=f'{INTEGRATION_NAME} Health Alert - Restarted without finishing',
                            status=dict(status, **{
                                'instance_name': demisto.integrationInstance(),
                                'last_run': json.dumps(last_run),
                                'message': status.get('message') or 'Restarted without finishing'
                            })
                        )

                cls.__cache['status'] = status

                # Save the context
                if sync:
                    if x is None:
                        x, xversion = IntegrationContextUtils.load()

                    x.update(cls.__cache)
                    IntegrationContextUtils.save(x, version=xversion)
                    cls.__last_sync = now

                if incident:
                    IntegrationContextUtils.__create_incident(**incident)

        @classmethod
        def clear_status(
            cls,
        ) -> None:
            """ Clear the status information
            """
            with cls.__lock:
                cls.__cache = {}

                x, xversion = IntegrationContextUtils.load()
                x.pop('status', None)
                x.pop('last_run', None)
                x.pop('last_error', None)
                IntegrationContextUtils.save(x, version=xversion)

        @classmethod
        def remove_status_keys(
            cls,
            keys: list[str],
        ) -> None:
            """ Remove the keys from the status information

            :param keys: List of the keys to remove from the status informaiton.
            """
            cls.update_status({k: None for k in keys})


    class Variables:
        """ Variables
        """
        @staticmethod
        def __eval_str(
            value: Any,
            gvars: dict[str, Any] | None,
            lvars: dict[str, Any] | None,
        ) -> Any:
            if isinstance(value, str):
                return eval(
                    "f'''" + value + "'''" if value.endswith('"') else 'f"""' + value + '"""',
                    gvars,
                    lvars
                )
            else:
                return value

        @staticmethod
        def __eval(
            gvars: dict[str, Any] | None,
            lvars: dict[str, Any] | None,
            nvars: dict[str, Any] | None,
        ) -> dict[str, Any] | None:
            if nvars is None:
                return lvars

            lvars = dict(lvars or {})
            for k, v in nvars.items():
                v = v if isinstance(v, dict) else {'value': v}
                vtype = v.get('type') or 'f-string'
                vval = v.get('value')
                if vtype == 'f-string':
                    lvars[k] = Variables.__eval_str(vval, gvars, lvars)
                elif vtype == 'raw':
                    lvars[k] = vval
                elif vtype == 'eval':
                    if isinstance(vval, str):
                        lvars[k] = eval(vval, gvars, lvars)
                    else:
                        lvars[k] = vval
                else:
                    raise DemistoException(f'Invalid variable type - {vtype}')
            return lvars

        def __init__(
            self,
            gvars: dict[str, Any] | None,
            lvars: dict[str, Any] | None,
        ) -> None:
            """ Initialize the instance

            :param gvars: Global variables (will be evaluated)
            :param lvars: Local variables (will be evaluated)
            """
            self.__gvars = Variables.__eval(None, None, gvars)
            self.__lvars = Variables.__eval(self.__gvars, None, lvars)

        def inherit(
            self,
            gvars: dict[str, Any] | None,
            lvars: dict[str, Any] | None,
        ) -> Self:
            """ Inherit with new variables

            :param gvars: New global variables (will be evaluated)
            :param lvars: New local variables (will be evaluated)
            :return: The new instance (Variables class).
            """
            v = Variables(None, None)
            v.__gvars = Variables.__eval(None, self.__gvars, gvars)
            v.__lvars = Variables.__eval(self.__gvars, self.__lvars, lvars)
            return v

        def eval_str(
            self,
            value: Any,
        ) -> Any:
            return Variables.__eval_str(value, self.__gvars, self.__lvars)

        def get_value(
            self,
            key: str,
        ) -> Any:
            v = (self.__lvars or {}).get(key)
            if v is None:
                v = (self.__gvars or {}).get(key)
            return v

        def update_local_vars(
            self,
            lvars: dict[str, Any] | None,
        ) -> None:
            if lvars is None:
                pass
            elif self.__lvars:
                self.__lvars.update(lvars)
            else:
                self.__lvars = lvars

        @property
        def global_vars(
            self
        ) -> dict[str, Any] | None:
            return self.__gvars

        @property
        def local_vars(
            self
        ) -> dict[str, Any] | None:
            return self.__lvars


    class IpEntries:
        """ IP Entries Manager
        """
        def __init__(
            self,
            entries: dict[str, dict[str, str]] = None,
        ) -> None:
            """ Initialize the instance

            :param users: IP attributes
            """
            self.__ents = entries if entries else {}

        @property
        def entries(
            self,
        ) -> dict[str, dict[str, str]]:
            return self.__ents

        def update(
            self,
            entries: dict[str, dict[str, str]] = None,
        ) -> None:
            """ Add and update with new IP entries

            :param users: IP attributes
            """
            self.__ents.update(entries if entries else {})

        def get_user_id_by_ip(
            self,
            ip: str | None
        ) -> str | None:
            """ Get the user ID associated with the IP

            :param ip: An IP address.
            :return: The user ID associated with the IP.
            """
            if ent := self.__ents.get(ip):
                return ent.get('user')
            return None

        def get_host_by_ip(
            self,
            ip: str | None
        ) -> str | None:
            """ Get the host name associated with the IP

            :param ip: An IP address.
            :return: The computer name associated with the IP.
            """
            if ent := self.__ents.get(ip):
                return ent.get('host')
            return None

        def get_domain_by_ip(
            self,
            ip: str | None
        ) -> str | None:
            """ Get the domain name associated with the IP

            :param ip: An IP address.
            :return: The domain name associated with the IP.
            """
            if ent := self.__ents.get(ip):
                return ent.get('domain')
            return None

        def get_fqdn_by_ip(
            self,
            ip: str | None
        ) -> str | None:
            """ Get the FQDN associated with the IP

            :param ip: An IP address.
            :return: The FQDN associated with the IP.
            """
            if ent := self.__ents.get(ip):
                if host := ent.get('host'):
                    if domain := ent.get('domain'):
                        return f'{host}.{domain}'
            return None

        def build_users(
            self,
        ) -> dict[str, dict[str, str]]:
            """ Build an user mapping table

            :return: The mapping table of users.
            """
            return {
                user: assign_params(
                    ip=ip,
                    domain=ent.get('domain'),
                    host=ent.get('host')
                ) for ip, ent in self.__ents.items() if (user := ent.get('user'))
            }


    class AsyncHttpClient:
        """ Async HTTP Client
        """
        def __init__(
            self,
            base_url: str,
            insecure: bool,
            proxies: dict[str, str] | None,
            credentials: Tuple[str, str] | None,
            timeout: int | None,
            retries: int = 0,
        ) -> None:
            """ Initialize the instance

            :param base_url: The base URL.
            :param insecure: Set true to accept untrusted SSL server certificates, otherwise false.
            :param proxies: Set proxy URLs in the values of 'http' and 'https' keys if needed.
            :param credentials: The user name and password for authentication.
            :param timeout: The timeout in seconds for connecting and I/O to the server.
            :param retries: The number of attempts to retry in requests.
            """
            self.__base_url = base_url
            self.__insecure = insecure
            self.__retries = max(0, retries)

            auth = None
            if credentials:
                auth = aiohttp.BasicAuth(
                    login=credentials[0],
                    password=credentials[1]
                )

            scheme = base_url.split(':', maxsplit=1)[0].lower()
            if keys := {
                'http': ['http'],
                'https': ['https', 'http'],
            }.get(scheme):
                self.__proxy = next(filter(None, [(proxies or {}).get(k) for k in keys]), None)
            else:
                raise DemistoException(f'Unknown protocol - {scheme}')

            self.__session = aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(
                    connect=timeout,
                    sock_connect=timeout,
                    sock_read=timeout
                ),
                auth=auth
            )

        async def __aenter__(
            self,
        ) -> Self:
            return self

        async def __aexit__(
            self,
            exc_type: type[BaseException] | None,
            exc_val: BaseException | None,
            traceback: TracebackType | None,
        ) -> None:
            await self.__session.close()

        async def __handle_response_error(
            self,
            resp: aiohttp.ClientResponse,
        ) -> None:
            text = await resp.text()
            err_msg = f'Error in API call [{resp.status}] - {resp.reason}\n{text}'
            raise DemistoException(err_msg, res=resp)

        def __build_url(
            self,
            suffix: str,
        ) -> str:
            url = self.__base_url if self.__base_url[-1:] == '/' else self.__base_url + '/'
            if suffix.startswith('/'):
                return url + suffix[1:]
            else:
                return url + suffix

        async def __request(
            self,
            method: str,
            url_suffix: str,
            params: dict[str, str] | None = None,
            headers: dict[str, str] | None = None,
            data: bytes | None = None,
            ok_codes: set[int] = (200,),
        ) -> aiohttp.ClientResponse:
            last_error = None
            for _ in range(self.__retries + 1):
                try:
                    resp = await self.__session.request(
                        method,
                        self.__build_url(url_suffix),
                        params=params,
                        headers=headers,
                        data=data,
                        ssl=not self.__insecure,
                        proxy=self.__proxy,
                    )
                    if resp.status not in ok_codes:
                        async with resp:
                            await self.__handle_response_error(resp)
                    return resp
                except (aiohttp.ConnectionTimeoutError, aiohttp.SocketTimeoutError, asyncio.TimeoutError) as e:
                    last_error = e
                    pass
            else:
                raise last_error

        async def get(
            self,
            url_suffix: str,
            headers: dict[str, str] = None,
            ok_codes: set[int] = (200,),
        ) -> aiohttp.ClientResponse:
            return await self.__request(
                method='GET',
                url_suffix=url_suffix,
                headers=headers,
                ok_codes=ok_codes,
            )

        async def get_content(
            self,
            url_suffix: str,
            headers: dict[str, str] = None,
            ok_codes: set[int] = (200,),
        ) -> bytes:
            async with await self.get(
                url_suffix=url_suffix,
                headers=headers,
                ok_codes=ok_codes,
            ) as resp:
                return await resp.read()

        async def post(
            self,
            url_suffix: str,
            params: dict[str, str] | None = None,
            headers: dict[str, str] | None = None,
            data: bytes | None = None,
            ok_codes: set[int] = (200,),
        ) -> aiohttp.ClientResponse:
            return await self.__request(
                method='POST',
                url_suffix=url_suffix,
                params=params,
                headers=headers,
                data=data,
                ok_codes=ok_codes,
            )

        async def close(
            self,
        ) -> None:
            await self.__session.close()


    class AsyncHttpClientProvider:
        """ Async HTTP Client Provider
        """
        def __init__(
            self,
            base_url: str,
            insecure: bool,
            proxies: dict[str, str] | None,
            credentials: Tuple[str, str] | None,
            timeout: int | None,
            retries: int = 0,
        ) -> None:
            self.__base_url = base_url
            self.__insecure = insecure
            self.__proxies = proxies
            self.__credentials = credentials
            self.__timeout = timeout
            self.__retries = retries

        def new(
            self,
        ) -> AsyncHttpClient:
            return AsyncHttpClient(
                base_url=self.__base_url,
                insecure=self.__insecure,
                proxies=self.__proxies,
                credentials=self.__credentials,
                timeout=self.__timeout,
                retries=self.__retries,
            )


    class RateLimiter:
        """ Rate Limiter
        """
        def __init__(
            self,
            rate_limit: float | None = None
        ) -> None:
            """ Initialize the instance

            :param rate_limit: The rate limit in Mbps.
            """
            self.__rate_limit = max(rate_limit, 0) if rate_limit else rate_limit
            self.__last_rating_time = 0
            self.__next_rating_time = 0
            self.__total_bytes_in_window = 0

        async def transmit(
            self,
            size: int
        ) -> None:
            """ Wait until the data transmitted in the bandwidth

            :param size: The size in bytes transmitted
            """
            self.__total_bytes_in_window += size
            if self.__rate_limit:
                now = time.time()
                if now >= self.__next_rating_time:
                    if self.__last_rating_time:
                        t = ((self.__total_bytes_in_window * 8) / (self.__rate_limit * 1024 * 1024))
                        t = t - (now - self.__last_rating_time)
                        if t >= 0:
                            until = datetime.datetime.now(datetime.UTC).isoformat(timespec='seconds')
                            demisto.info(
                                f'Wait {int(t)} seconds (until {until}) due to the rate limit.'
                            )
                            await asyncio.sleep(t)
                        self.__total_bytes_in_window = 0

                    self.__last_rating_time = now
                    self.__next_rating_time = now + 60


    class LogEncoder:
        """ Log Encoder
        """
        @staticmethod
        def __encode_cef_header(
            val: Any
        ) -> str:
            if isinstance(val, (list, dict)):
                val = json.dumps(val)
            else:
                val = '' if val is None else str(val)

            m = {'|': r'\|', '\\': '\\\\'}
            return re.sub(r'[|\\]', lambda x:m[x[0]], val)

        @staticmethod
        def __encode_cef_value(
            val: Any
        ) -> str:
            if isinstance(val, (list, dict)):
                val = json.dumps(val)
            else:
                val = '' if val is None else str(val)

            m = {'\n': r'\n', '\r': r'\r', '\t': r'\t', '=': r'\=', '\\': '\\\\'}
            return re.sub(r'[=\\\r\n]', lambda x:m[x[0]], val)

        def __init__(
            self,
            settings: Settings,
            preferred_log_format: str,
            preferred_syslog_header: str | None,
            cef_version: int | str,
            cef_vendor: str,
            cef_product: str,
            cef_device_version: str,
            cef_device_event_class_id: str,
            cef_name: str,
            cef_severity: str,
            log_params: str | dict[str, Any],
            source_hostname: str | None = None,
            app_process_name: str | None = None,
            app_process_id: int | str | None = None
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            :param preferred_log_format: The preferred log receiver (raw, cef, or json/*-json).
            :param preferred_syslog_header: The preferred syslog header ('RFC 3164' or 'RFC 5424').
            :param cef_version: CEF version in CEF fields.
            :param cef_vendor: vendor name in CEF fields.
            :param cef_product: product name in CEF fields.
            :param cef_device_version: device version in CEF fields.
            :param cef_device_event_class_id: device event class ID in CEF fields.
            :param cef_name: name in CEF fields.
            :param cef_severity: severity in CEF fields.
            :param log_params: raw log (str) or keyed-value log parameters (dict).
            :param source_hostname: A host name where the logging application is running.
            :param app_process_name: The process name of the application.
            :param app_process_id: The process ID of the application.
            """
            self.__settings = settings
            self.__preferred_log_format = preferred_log_format
            self.__preferred_syslog_header = preferred_syslog_header
            self.__cef_version = str(cef_version)
            self.__cef_vendor = cef_vendor
            self.__cef_product = cef_product
            self.__cef_device_version = cef_device_version
            self.__cef_device_event_class_id = cef_device_event_class_id
            self.__cef_name = cef_name
            self.__cef_severity = cef_severity
            self.__log_params = log_params
            self.__source_hostname = source_hostname
            self.__app_process_name = str(app_process_name) if app_process_name else None
            self.__app_process_id = str(app_process_id) if app_process_id is not None else None
            self.__log_time = settings.log_now()
            self.__cef_cache: dict[str, str] = {}
            self.__raw_cache: dict[str, str] = {}
            self.__json_cache: dict[str, dict[str, Any]] = {}

        def __build_syslog_header(
            self,
            syslog_format: str | None
        ) -> str:
            """ Build a syslog header.

            :param syslog_format: Syslog format (RFC 3164 or RFC 5424).
            :return: Syslog header with the last separator.
            """
            if syslog_format:
                now = self.__log_time
                source_hostname = self.__source_hostname or '-'
                pri = self.__settings.syslog_header_pri
                if syslog_format == SyslogHeaderType.RFC_3164:
                    tag = ''
                    if self.__app_process_name:
                        if self.__app_process_id:
                            tag = f'{self.__app_process_name}[{self.__app_process_id}]: '
                        else:
                            tag = f'{self.__app_process_name}: '

                    return f'<{pri}>{now.strftime("%b %d %H:%M:%S")} {source_hostname} {tag}'
                elif syslog_format == SyslogHeaderType.RFC_5424:
                    tz = now.strftime('%z')
                    tz = 'Z' if tz.endswith('0000') else f'{tz[:3]}:{tz[3:]}'
                    app_name = self.__app_process_name or '-'
                    proc_id = self.__app_process_id or '-'
                    return f'<{pri}>1 {now.strftime("%Y-%m-%dT%H:%M:%S")}{tz} {source_hostname} {app_name} {proc_id} - - '
            return ''

        def __format_syslog(
            self,
            log_format: str,
            log_message: str,
        ) -> str:
            """ Build a syslog message.

            :param log_format: The syslog format (RFC 3164 or RFC 5424).
            :param log_message: The log message.
            :return: A syslog log message built.
            """
            return self.__build_syslog_header(log_format) + log_message

        def __build_json_dict(
            self,
            raw_syslog_format: str | None = None,
        ) -> dict[str, Any]:
            """ Build log parameters in dict for JSON receivers.

            :param raw_syslog_format: Set syslog format (RFC 3164 or RFC 5424) for the raw log.
            :return: Log parameters in dict.
            """
            match self.__preferred_log_format:
                case 'raw':
                    return {
                        '_raw_log': self.__build_syslog_header(raw_syslog_format) + str(self.__log_params)
                    }

                case 'cef':
                    if isinstance(self.__log_params, dict):
                        return self.__log_params
                    else:
                        return {
                            '__raw_json': self.__log_params
                        }

                case x if x.endswith('-json') or x == 'json':
                    if isinstance(self.__log_params, dict):
                        return self.__log_params
                    else:
                        return {
                            '__raw_json': self.__log_params
                        }

                case _:
                    raise DemistoException(f'Invalid preferred_log_format log type - {self.__preferred_log_format}')

        def __build_cef(
            self,
            raw_syslog_format: str | None = None,
        ) -> str:
            """ Build a log message in CEF format.

            :param raw_syslog_format: Set syslog format (RFC 3164 or RFC 5424) for the raw log.
            :return: A log message in CEF format.
            """
            exts = self.__log_params
            if not isinstance(exts, dict):
                exts = {
                    '_raw_log': self.__build_syslog_header(raw_syslog_format) + str(exts)
                }

            return 'CEF:' + '|'.join([
                LogEncoder.__encode_cef_header(self.__cef_version),
                LogEncoder.__encode_cef_header(self.__cef_vendor),
                LogEncoder.__encode_cef_header(self.__cef_product),
                LogEncoder.__encode_cef_header(self.__cef_device_version),
                LogEncoder.__encode_cef_header(self.__cef_device_event_class_id),
                LogEncoder.__encode_cef_header(self.__cef_name),
                LogEncoder.__encode_cef_header(self.__cef_severity),
                ' '.join([
                    f'{LogEncoder.__encode_cef_value(k)}={LogEncoder.__encode_cef_value(v)}'
                    for k, v in exts.items()
                ])
            ])

        def __build_raw(
            self,
            syslog_format: str | None = None
        ) -> str:
            """ Build a raw log message.

            :param syslog_format: Set syslog format (RFC 3164 or RFC 5424) if needed.
            :return: A raw log message.
            """
            match self.__preferred_log_format:
                case 'raw':
                    if isinstance(self.__log_params, (dict, list)):
                        msg = json.dumps(self.__log_params)
                    else:
                        msg = str(self.__log_params)
                    return self.__format_syslog(syslog_format, msg)

                case 'cef':
                    return self.__format_syslog(syslog_format, self.build_cef(None))

                case x if x.endswith('-json') or x == 'json':
                    return self.__format_syslog(syslog_format, self.build_cef(None))

                case _:
                    raise DemistoException(f'Invalid preferred log type - {self.__preferred_log_format}')

        @property
        def preferred_log_format(
            self,
        ) -> str:
            return self.__preferred_log_format

        def get_preferred_syslog_header_format(
            self,
            default_syslog_format: str | None,
            enforcement_level: str | None,
        ) -> str | None:
            """ Get the preferred syslog header format.

            :param default_syslog_format: The default syslog header format (RFC 3164 or RFC 5424) if needed.
            :param enforcement_level: The enforcement level for the log specific syslog header format.
            :return: The preferred syslog header format.
            """
            if enforcement_level == SyslogHeaderTypeEnforcement.ALWAYS:
                return self.__preferred_syslog_header or default_syslog_format
            elif enforcement_level == SyslogHeaderTypeEnforcement.ADAPTIVE:
                if self.__preferred_syslog_header and default_syslog_format:
                    return self.__preferred_syslog_header
            return default_syslog_format

        def build_json_dict(
            self,
            raw_syslog_format: str | None = None,
        ) -> dict[str, Any]:
            """ Build log parameters in dict for JSON receivers.

            :param raw_syslog_format: Set syslog format (RFC 3164 or RFC 5424) for the raw log.
            :return: Log parameters in dict.
            """
            if isinstance(self.__log_params, dict):
                raw_syslog_format = None

            params = self.__json_cache.get(raw_syslog_format)
            if params is None:
                params = self.__build_json_dict(raw_syslog_format)
                self.__json_cache[raw_syslog_format] = params
            return params

        def build_cef(
            self,
            raw_syslog_format: str | None = None,
        ) -> str:
            """ Build a log message in CEF format.

            :param raw_syslog_format: Set syslog format (RFC 3164 or RFC 5424) for the raw log.
            :return: A log message in CEF format.
            """
            if isinstance(self.__log_params, dict):
                raw_syslog_format = None

            log = self.__cef_cache.get(raw_syslog_format)
            if log is None:
                log = self.__build_cef(raw_syslog_format)
                self.__cef_cache[raw_syslog_format] = log
            return log

        def build_raw(
            self,
            syslog_format: str | None = None
        ) -> str:
            """ Build a raw log message.

            :param syslog_format: Set syslog format (RFC 3164 or RFC 5424) if needed.
            :return: A raw log message.
            """
            log = self.__raw_cache.get(syslog_format)
            if log is None:
                log = self.__build_raw(syslog_format)
                self.__raw_cache[syslog_format] = log
            return log


    class HecLogSender:
        """ Log sender for XDR/XSIAM HTTP Collector
        """
        class BufferedSender:
            """ Buffered Log sender for XDR/XSIAM HTTP Collector
            """
            def __init__(
                self,
                client: AsyncHttpClient,
                api_key: str,
                compression: bool,
                buffer_size: int = DEFAULT_HEC_UPLOAD_BUFFER_SIZE,
                rate_limit: float | None = None
            ) -> None:
                """ Initialize the instance

                :param settings: The instance settings.
                :param client: The HTTP client for XDR/XSIAM HTTP Collector
                :param api_key: An API Key for XDR/XSIAM HTTP Collector
                :param compression: Set to True to compress logs by gzip, otherwise False.
                :param buffer_size: The size of sending buffer.
                :param rate_limit: The rate limit in Mbps.
                """
                self.__client = client
                self.__api_key = api_key
                self.__compression = compression
                self.__rate_limiter = RateLimiter(rate_limit)
                self.__buffer = io.BytesIO()
                self.__buffer_size = buffer_size
                self.__nlogs_buffered = 0
                self.__nlogs_sent = 0
                if compression:
                    self.__log_writer = gzip.GzipFile(mode='wb', fileobj=self.__buffer)
                    self.__content_type = 'application/gzip'
                    self.__content_encoding = 'gzip'
                else:
                    self.__log_writer = self.__buffer
                    self.__content_type = 'text/plain'
                    self.__content_encoding = None

            @property
            def nlogs_buffered(
                self,
            ) -> int:
                """ Get the number of log entries buffered.

                :return: The number of log entries buffered.
                """
                return self.__nlogs_buffered

            @property
            def nlogs_sent(
                self,
            ) -> int:
                """ Get the number of log entries sent to the HEC

                :return: The number of log entries sent.
                """
                return self.__nlogs_sent

            async def send_log(
                self,
                log: str,
            ) -> int:
                """ Send an event log

                :param log: An event log
                :return: The number of log entries flushed.
                """
                self.__log_writer.write((log + '\n').encode())
                self.__nlogs_buffered += 1

                if self.__buffer.getbuffer().nbytes >= self.__buffer_size:
                    return await self.flush()
                else:
                    return 0

            async def flush(
                self
            ) -> int:
                """ Finish writing logs

                :return: The number of log entries flushed.
                """
                if not self.__nlogs_buffered:
                    return 0

                if self.__compression:
                    self.__log_writer.close()

                # Flush the cache
                data = self.__buffer.getvalue()
                async with await self.__client.post(
                    url_suffix='/logs/v1/event',
                    headers=assign_params(**{
                        'Authorization': self.__api_key,
                        'Content-Type': self.__content_type,
                        'Content-Encoding': self.__content_encoding,
                    }),
                    data=data,
                ) as resp:
                    await resp.json()

                await self.__rate_limiter.transmit(len(data))
                nlogs = self.__nlogs_buffered
                self.__nlogs_sent += nlogs
                self.__nlogs_buffered = 0

                # Re-initialize the cache
                self.__buffer = io.BytesIO()
                if self.__compression:
                    self.__log_writer = gzip.GzipFile(mode='wb', fileobj=self.__buffer)
                else:
                    self.__log_writer = self.__buffer

                return nlogs

            async def test(
                self
            ) -> None:
                """ Test connectivity
                """
                # Test to connect to XSIAM
                body = io.BytesIO()
                if self.__compression:
                    gzip.GzipFile(mode='wb', fileobj=body).close()

                async with await self.__client.post(
                    url_suffix='/logs/v1/event',
                    headers={
                        'Authorization': self.__api_key,
                        'Content-Type': self.__content_type,
                    },
                    data=body.getvalue(),
                ) as resp:
                    await resp.json()


        def __init__(
            self,
            provider: AsyncHttpClientProvider,
            api_key: str,
            compression: bool,
            buffer_size: int = DEFAULT_HEC_UPLOAD_BUFFER_SIZE,
            rate_limit: float | None = None
        ) -> None:
            """ Initialize the instance

            :param provider: The HTTP client for XDR/XSIAM HTTP Collector
            :param api_key: An API Key for XDR/XSIAM HTTP Collector
            :param compression: Set to True to compress logs by gzip, otherwise False.
            :param buffer_size: The size of sending buffer.
            :param rate_limit: The rate limit in Mbps.
            """
            self.__client = provider.new()
            self.__sender = HecLogSender.BufferedSender(
                client=self.__client,
                api_key=api_key,
                compression=compression,
                buffer_size=buffer_size,
                rate_limit=rate_limit,
            )
            self.__done = False
            self.__alock = asyncio.Lock()
            self.__last_flush_time = time.time()

        async def __aenter__(
            self,
        ) -> Self:
            return self

        async def __aexit__(
            self,
            exc_type: type[BaseException] | None,
            exc_val: BaseException | None,
            traceback: TracebackType | None,
        ) -> None:
            self.__done = True
            await self.__client.close()

        @property
        def nlogs_buffered(
            self,
        ) -> int:
            """ Get the number of log entries buffered

            :return: The number of log entries buffered.
            """
            return self.__sender.nlogs_buffered

        @property
        def nlogs_sent(
            self,
        ) -> int:
            """ Get the number of log entries sent to the HEC

            :return: The number of log entries sent.
            """
            return self.__sender.nlogs_sent

        @property
        def last_flush(
            self,
        ) -> float:
            """ Get the last time in Epoch time when logs were flushed.

            :return: The last time in Epoch time when logs were flushed.
            """
            return self.__last_flush_time

        async def send_log(
            self,
            log: str,
        ) -> None:
            """ Send an event log

            :param log: An event log
            """
            if log:
                if self.__done:
                    raise DemistoException('The log sender has been shutdown.')

                async with self.__alock:
                    await self.__sender.send_log(log)

        async def flush(
            self,
        ) -> None:
            """ Flush buffered logs
            """
            if self.__done:
                raise DemistoException('The log sender has been shutdown.')

            async with self.__alock:
                self.__last_flush_time = time.time()
                await self.__sender.flush()

        async def finish(
            self,
        ) -> None:
            """ Finish sending logs
            """
            if not self.__done:
                async with self.__alock:
                    self.__done = True
                    await self.__sender.flush()
                    await self.__client.close()

        async def test(
            self,
        ) -> None:
            """ Test connectivity
            """
            async with self.__alock:
                return await self.__sender.test()


    class SyslogLogSender:
        """ Log sender for syslog
        """
        def __init__(
            self,
            ip_proto: str,
            host: str,
            port: int,
            timeout: int | None = None,
            rate_limit: float | None = None
        ) -> None:
            """ Initialize the instance

            :param ip_proto: The IP protocol (UDP or TCP).
            :param host: The host name of the syslog server.
            :param port: The port number of the syslog server.
            :param timeout: The socket timeout in second.
            :param rate_limit: The rate limit in Mbps.
            """
            self.__rate_limiter = RateLimiter(rate_limit)
            self.__alock = asyncio.Lock()
            self.__timeout = timeout
            self.__remote_addr = (host, port)
            self.__udp = None
            self.__tcp = None
            self.__init, self.__send_log = {
                'udp': (self.__init_udp, self.__send_log_udp),
                'tcp': (self.__init_tcp, self.__send_log_tcp),
            }.get(ip_proto.lower()) or (None, None)

            if not self.__send_log:
                raise DemistoException(f'Invalid IP protocol - {ip_proto}')

        async def __init_udp(
            self,
        ) -> None:
            self.__udp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.__udp.setblocking(False)

        async def __init_tcp(
            self,
        ) -> None:
            r, w = await asyncio.wait_for(
                asyncio.open_connection(*self.__remote_addr),
                timeout=self.__timeout
            )
            self.__tcp = w

        async def __send_log_udp(
            self,
            log: str,
        ) -> int:
            """ Send an log message over UDP

            :param log: A log message.
            :return: The length of the log message written.
            """
            if not self.__udp:
                raise DemistoException('This sender has already been closed.');

            data = log.encode()
            loop = asyncio.get_running_loop()
            await asyncio.wait_for(
                loop.sock_sendto(self.__udp, data, self.__remote_addr),
                timeout=self.__timeout
            )
            return len(data)

        async def __send_log_tcp(
            self,
            log: str,
        ) -> None:
            """ Send an log message over TCP

            :param log: A log message.
            :return: The length of the log message written.
            """
            if not self.__tcp:
                raise DemistoException('This sender has already been closed.');

            payload = log.encode()
            data = f'{len(payload)} '.encode() + payload
            self.__tcp.write(data)
            await asyncio.wait_for(
                self.__tcp.drain(),
                timeout=self.__timeout
            )
            return len(data)

        async def init(
            self,
        ) -> None:
            """ Prepare to send logs
            """
            async with self.__alock:
                if self.__init:
                    self.__init = await self.__init()

        async def send_log(
            self,
            log: str,
        ) -> None:
            """ Send an log message

            :param log: A log message.
            """
            if not log:
                return

            async with self.__alock:
                if self.__init:
                    self.__init = await self.__init()

                await self.__rate_limiter.transmit(
                    await self.__send_log(log)
                )

        async def finish(
            self
        ) -> None:
            """ Finish sending logs
            """
            async with self.__alock:
                if self.__udp:
                    self.__udp = self.__udp.close()
                if self.__tcp:
                    self.__tcp.close()
                    await asyncio.wait_for(
                        self.__tcp.wait_closed(),
                        timeout=self.__timeout
                    )
                    self.__tcp = None


    class LogSender:
        """ Log Sender for HEC and Broker VM
        """
        def __init__(
            self,
            settings: Settings
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            """
            self.__done = False
            self.__settings = settings
            if settings.xsiam_hc_enable:
                if not settings.xsiam_api_url:
                    raise DemistoException('XSIAM API URL is not configured.')

                provider = AsyncHttpClientProvider(
                    base_url=settings.xsiam_api_url,
                    insecure=settings.insecure,
                    proxies=settings.proxies or None,
                    credentials=None,
                    timeout=settings.socket_timeout,
                    retries=DEFAULT_HTTP_RETRIES,
                )
                self.__hc_raw_sender, self.__hc_cef_sender = map(
                    lambda api_key: HecLogSender(
                        provider=provider,
                        api_key=api_key,
                        compression=settings.xsiam_hc_compression,
                        buffer_size=settings.xsiam_hc_buffer_size,
                        rate_limit=settings.rate_limit,
                    ) if api_key else None,
                    [
                        settings.xsiam_hc_api_key_raw,
                        settings.xsiam_hc_api_key_cef,
                    ]
                )
            else:
                self.__hc_raw_sender = None
                self.__hc_cef_sender = None

            if settings.syslog_transport_enable:
                if not settings.syslog_transport_address:
                    raise DemistoException('Syslog Address is not configured.')

                syslog_host, syslog_port = settings.syslog_transport_address
                self.__syslog_sender = SyslogLogSender(
                    ip_proto=settings.syslog_transport_protocol,
                    host=syslog_host,
                    port=syslog_port,
                    timeout=settings.socket_timeout,
                    rate_limit=settings.rate_limit
                )
            else:
                self.__syslog_sender = None

            if not any([
                self.__syslog_sender,
                self.__hc_raw_sender,
                self.__hc_cef_sender
            ]):
                raise DemistoException('No logging targets are configured.')

            self.__cnt_syslog = 0

        async def __aenter__(
            self,
        ) -> Self:
            return self

        async def __aexit__(
            self,
            exc_type: type[BaseException] | None,
            exc_val: BaseException | None,
            traceback: TracebackType | None,
        ) -> None:
            if not self.__done:
                self.__done = True
                for s in filter(None, [
                    self.__hc_raw_sender,
                    self.__hc_cef_sender,
                    self.__syslog_sender,
                ]):
                    await s.finish()

        def __update_stats(
            self,
            final: bool
        ) -> None:
            log_stats = {}
            if self.__hc_raw_sender:
                log_stats['hec_raw'] = {
                    'queued': self.__hc_raw_sender.nlogs_buffered,
                    'sent': self.__hc_raw_sender.nlogs_sent,
                    'finished': final,
                }
            if self.__hc_cef_sender:
                log_stats['hec_cef'] = {
                    'queued': self.__hc_cef_sender.nlogs_buffered,
                    'sent': self.__hc_cef_sender.nlogs_sent,
                    'finished': final,
                }
            if self.__syslog_sender:
                log_stats['syslog'] = {
                    'sent': self.__cnt_syslog,
                    'finished': final,
                }

            IntegrationContextUtils.update_status({
                'log_stats': log_stats
            })

        async def __send_log_hc_raw(
            self,
            log: LogEncoder,
        ) -> None:
            """ Send an event log

            :param log: An event log
            """
            if not self.__done and self.__hc_raw_sender:
                msg = log.build_raw(
                    log.get_preferred_syslog_header_format(
                        self.__settings.xsiam_hc_transportation_format,
                        self.__settings.xsiam_hc_enforce_log_spec_syslog_format,
                    )
                )
                await self.__hc_raw_sender.send_log(msg)

        async def __send_log_hc_cef(
            self,
            log: LogEncoder,
        ) -> None:
            """ Send an event log

            :param log: An event log
            """
            if not self.__done and self.__hc_cef_sender:
                msg = log.build_cef(
                    log.get_preferred_syslog_header_format(
                        self.__settings.xsiam_hc_transportation_format,
                        self.__settings.xsiam_hc_enforce_log_spec_syslog_format,
                    )
                )
                await self.__hc_cef_sender.send_log(msg)

        async def __send_log_syslog(
            self,
            log: LogEncoder,
        ) -> None:
            """ Send an event log

            :param log: An event log
            """
            if not self.__done and self.__syslog_sender:
                msg = log.build_raw(
                    log.get_preferred_syslog_header_format(
                        self.__settings.syslog_transport_format,
                        self.__settings.syslog_transport_enforce_log_spec_format,
                    )
                )
                await self.__syslog_sender.send_log(msg)
                self.__cnt_syslog += 1

        async def send_log(
            self,
            log: LogEncoder,
        ) -> None:
            """ Send an event log

            :param log: An event log
            """
            if self.__done:
                return

            if log.preferred_log_format == 'cef' and self.__hc_cef_sender:
                await self.__send_log_hc_cef(log)

            elif (
                self.__hc_cef_sender and
                log.preferred_log_format == 'raw' and
                self.__settings.xsiam_hc_raw_log_to_cef
            ):
                await self.__send_log_hc_cef(log)

            elif log.preferred_log_format == 'raw' and self.__hc_raw_sender:
                await self.__send_log_hc_raw(log)

            elif self.__hc_cef_sender:
                await self.__send_log_hc_cef(log)

            elif self.__hc_raw_sender:
                await self.__send_log_hc_raw(log)

            if self.__syslog_sender:
                await self.__send_log_syslog(log)

        async def flush(
            self
        ) -> None:
            """ Flush logs to the devices
            """
            if not self.__done:
                for s in filter(None, [
                    self.__hc_raw_sender,
                    self.__hc_cef_sender,
                ]):
                    await s.flush()

        async def finish(
            self
        ) -> None:
            """ Finish sending logs
            """
            if not self.__done:
                self.__done = True
                for s in filter(None, [
                    self.__hc_raw_sender,
                    self.__hc_cef_sender,
                    self.__syslog_sender,
                ]):
                    await s.finish()
                self.__update_stats(True)

        async def run_bg_process(
            self,
        ) -> None:
            """ Run the background processes for log sending.
            """
            while not self.__done:
                # Flush logs
                now = time.time()
                for s in filter(
                    lambda s: s and now - s.last_flush >= DEFAULT_LOG_FLUSH_INTERVAL,
                    [
                        self.__hc_raw_sender,
                        self.__hc_cef_sender,
                    ]
                ):
                    await s.flush()
                    demisto.debug('logs have been flushed by the background process.')

                # Update log stats
                self.__update_stats(False)

                await asyncio.sleep(
                    min(DEFAULT_LOG_FLUSH_INTERVAL, DEFAULT_STATUS_UPDATE_INTERVAL)
                )

        async def test(
            self
        ) -> None:
            """ Test connectivity
            """
            if self.__syslog_sender:
                await self.__syslog_sender.init()

            for s in filter(None, [
                self.__hc_raw_sender,
                self.__hc_cef_sender,
            ]):
                await s.test()


    class GetHostByName:
        """ Translate a host name to IPv4 address format.
        """
        def __init__(
            self,
            hostname: str,
            default_ip: str | None = None
        ):
            """ Initialize the instance

            :param hostname: A host name to look up its IP address.
            :param default_ip: The default IP address to return when socket.gethostbyname fails.
            """
            self.__hostname = hostname
            self.__default_ip = default_ip
            self.__resolved_ip = None

        def __str__(
            self,
        ) -> str:
            """ Get an IP address of the host name.

            :return: An IP address resolved. Return an empty stirng if failed.
            """
            if self.__resolved_ip is None:
                try:
                    self.__resolved_ip = socket.gethostbyname(self.__hostname)
                except socket.gaierror:
                    self.__resolved_ip = '' if self.__default_ip is None else self.__default_ip

            return self.__resolved_ip

        async def resolve_ip(
            self,
        ) -> str:
            """ Get an IP address of the host name.

            :return: An IP address resolved. Return an empty stirng if failed.
            """
            if self.__resolved_ip is None:
                resolved_ip = '' if self.__default_ip is None else self.__default_ip
                try:
                    SockInfo = namedtuple('SockInfo', 'family type proto cannon sockaddr')
                    for ai in await asyncio.get_running_loop().getaddrinfo(self.__hostname, 0):
                        if resolved_ip := SockInfo._make(ai).sockaddr[0]:
                            break
                except socket.gaierror:
                    pass

                self.__resolved_ip = resolved_ip

            return self.__resolved_ip


    ''' LogGenerator CLASSES '''


    class LogGenerator(object):
        """ Log Generator
        """
        __metaclass__ = ABCMeta

        @abstractmethod
        def generate(
            self,
            props: dict[str, Any]
        ) -> LogEncoder | None:
            pass


    class CheckPointLogGenerator(LogGenerator):
        """ Check Point Log Generator
        """
        def __init__(
            self,
            settings: Settings,
            format_type: str
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            :param format_type: 'traffic'
            """
            self.__settings = settings
            self.__format_type = format_type
            self.__preferred_syslog_header = settings.syslog_preferred_headers.get('checkpoint') or None

        def generate(
            self,
            props: dict[str, Any]
        ) -> LogEncoder | None:
            if self.__format_type == 'traffic':
                exts = assign_params(
                    act={
                        'allow': 'accept',
                        'deny': 'drop',
                    }.get(props.get('fw_action')) or 'accept',
                    spt=props.get('src_port'),
                    dpt=props.get('dst_port'),
                    dst=props.get('dst_ip'),
                    src=props.get('src_ip'),
                    app=props.get('app_protocol'),
                    proto=(props.get('ip_protocol') or '').upper()
                )
                return LogEncoder(
                    settings=self.__settings,
                    preferred_log_format='cef',
                    preferred_syslog_header=self.__preferred_syslog_header,
                    cef_version=0,
                    cef_vendor='Check Point',
                    cef_product='VPN-1 & FireWall-1',
                    cef_device_version='Check Point',
                    cef_device_event_class_id='Log',
                    cef_name=props.get('app_protocol'),
                    cef_severity='informational',
                    log_params=exts
                )
            else:
                raise DemistoException(f'Invalid log format type - {self.__format_type}')


    class FortiGateLogGenerator(LogGenerator):
        """ FortiGate Log Generator
        """
        def __init__(
            self,
            settings: Settings,
            format_type: str
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            :param format_type: 'traffic'
            """
            self.__settings = settings
            self.__format_type = format_type
            self.__preferred_syslog_header = settings.syslog_preferred_headers.get('fortigate') or None

        def generate(
            self,
            props: dict[str, Any]
        ) -> LogEncoder | None:
            if self.__format_type == 'traffic':
                proto = {
                    'udp': 17,
                    'tcp': 6,
                }.get(props.get('ip_protocol')) or 6

                app = {
                    'http': 'http',
                    'https': 'https',
                    'dns': 'dns'
                }.get(props.get('app_protocol')) or (
                    (props.get('ip_protocol') or 'tcp') +
                    '/' +
                    str(props.get('dst_port') or 0)
                ).lower()

                action = {
                    'allow': 'close',
                    'deny': 'deny',
                }.get(props.get('fw_action')) or 'close'

                in_bytes = {
                    'http': random.randint(128, 1 * (1024 ** 2)),
                    'https': random.randint(1024, 100 * (1024 ** 2)),
                    'dns': random.randint(256, 512),
                }.get(props.get('app_protocol')) or random.randint(128, 128 * 1024)

                out_bytes = {
                    'http': random.randint(128, 2 * 1024),
                    'https': random.randint(1024, 10 * (1024 ** 2)),
                    'dns': random.randint(128, 256),
                }.get(props.get('app_protocol')) or random.randint(128, 128 * 1024)

                utcnow = datetime.datetime.now(datetime.UTC)
                exts = assign_params(
                    FTNTFGTapplist='g-default',
                    FTNTFGTcountapp=2,
                    FTNTFGTdstintfrole='undefined',
                    FTNTFGTduration=max(round(in_bytes / (1024 * 10)), 1),
                    FTNTFGTeventtime=int(utcnow.timestamp()),
                    FTNTFGTlevel='notice',
                    FTNTFGTpolicyid=1,
                    FTNTFGTpolicytype='policy',
                    FTNTFGTpoluuid='c2d460aa-fe6f-51e8-9505-41b5117dfdd4',
                    FTNTFGTsrccountry='Reserved',
                    FTNTFGTsrcintfrole='undefined',
                    FTNTFGTsubtype='forward',
                    act=action,
                    app=app,
                    cat='traffic:forward',
                    deviceExternalId='FGT5HD0000000000',
                    deviceInboundInterface='port12',
                    deviceOutboundInterface='port11',
                    dpt=props.get('dst_port'),
                    dst=props.get('dst_ip'),
                    externalId=402,
                    out=out_bytes,
                    proto=proto,
                    spt=props.get('src_port'),
                    src=props.get('src_ip'),
                )
                exts['in'] = in_bytes

                return LogEncoder(
                    settings=self.__settings,
                    preferred_log_format='cef',
                    preferred_syslog_header=self.__preferred_syslog_header,
                    cef_version=0,
                    cef_vendor='Fortinet',
                    cef_product='Fortigate',
                    cef_device_version='v6.0.3',
                    cef_device_event_class_id='00013',
                    cef_name=f'traffic:forward {action}',
                    cef_severity='3',
                    log_params=exts
                )
            else:
                raise DemistoException(f'Invalid log format type - {self.__format_type}')


    class NGFWLogGenerator(LogGenerator):
        """ Palo Alto Networks NGFW Log Generator
        """
        def __init__(
            self,
            settings: Settings,
            log_type: str
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            :param log_type: 'traffic', 'threat' or 'url'
            """
            if log_type not in ('traffic', 'threat', 'url'):
                raise DemistoException(f'Invalid log type - {log_type}')

            self.__settings = settings
            self.__log_type = log_type
            self.__preferred_syslog_header = settings.syslog_preferred_headers.get('ngfw') or None
            self.__seq_no = int(time.time() * (2 ** 32))
            self.__sess_id = 0
            self.__serial_no = '012345678901234'

        def generate(
            self,
            props: dict[str, Any]
        ) -> LogEncoder | None:
            utcnow, now = self.__settings.log_now2()
            local_TZ = now.strftime('%z')
            local_tz = f'{local_TZ[:3]}:{local_TZ[3:]}'
            seq_no = self.__seq_no
            self.__seq_no += 1
            sess_id = self.__sess_id
            self.__sess_id += 1

            action = {
                'allow': 'allow',
                'deny': 'drop',
            }.get(props.get('fw_action')) or 'allow'

            # Default app
            app_protocol = props.get('app_protocol')
            if app_protocol in ('http', 'https'):
                url_comps = urllib.parse.urlparse(props.get('http.url') or '')
                if 'git' in url_comps.netloc:
                    app = 'github-base'
                elif 'google' in url_comps.netloc:
                    app = 'google-base'
                elif app_protocol == 'https':
                    app = 'ssl'
                else:
                    app = 'web-browsing'
            else:
                app = {
                    'http': 'web-browsing',
                    'https': 'ssl',
                    'dns': 'dns-base',
                    'ssh': 'ssh',
                }.get(app_protocol)

            app = app or app_protocol
            if not app:
                ip_protocol = props.get('ip_protocol') or 'tcp'
                if ip_protocol == 'tcp':
                    app = {
                        '22': 'ssh',
                        '53': 'dns-base',
                        '88': 'kerberos',
                        '110': 'pop3',
                        '135': 'msrpc-base',
                        '143': 'imap',
                        '389': 'ldap',
                        '445': 'ms-ds-smbv3',
                        '514': 'syslog',
                        '3389': 'ms-rdp',
                    }.get(str(props.get('dst_port')))
                elif ip_protocol == 'udp':
                    app = {
                        '53': 'dns-base',
                        '123': 'ntp-base',
                        '137': 'netbios-ns',
                        '138': 'netbios-dg',
                        '514': 'syslog',
                        '2055': 'netflow',
                    }.get(str(props.get('dst_port')))

            if not app:
                app = {
                    'udp': 'unknown-udp',
                    'tcp': 'unknown-tcp'
                }.get(props.get('ip_protocol') or 'tcp')

            if self.__log_type == 'traffic':
                in_bytes = {
                    'http': random.randint(128, 1 * (1024 ** 2)),
                    'https': random.randint(1024, 100 * (1024 ** 2)),
                    'dns': random.randint(256, 512),
                }.get(props.get('app_protocol')) or random.randint(128, 128 * 1024)

                out_bytes = {
                    'http': random.randint(128, 2 * 1024),
                    'https': random.randint(1024, 10 * (1024 ** 2)),
                    'dns': random.randint(128, 256),
                }.get(props.get('app_protocol')) or random.randint(128, 128 * 1024)

                exts = {
                    '__firewall_type': 'firewall.traffic',
                    '__timestamp': now.strftime('%Y/%m/%d %H:%M:%S'),
                    '__tz': now.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + local_tz,
                    'action': action,
                    'app': app,
                    'app_category': 'networking',
                    'app_sub_category': 'infrastructure',
                    'bytes_received': in_bytes,
                    'bytes_sent': out_bytes,
                    'dest_device_category': '',
                    'dest_device_mac': '',
                    'dest_device_model': '',
                    'dest_device_osfamily': '',
                    'dest_device_osversion': '',
                    'dest_device_profile': '',
                    'dest_device_vendor': '',
                    'dest_ip': props.get('dst_ip'),
                    'dest_port': props.get('dst_port'),
                    'dest_user': props.get('dst_user'),
                    'from_zone': 'slp',
                    'inbound_if': 'ethernet1/1',
                    'log_source_id': self.__serial_no,
                    'log_source_name': 'panw-ngfw',
                    'log_time': utcnow.strftime('%b %d %Y %H:%M:%S GMT'),
                    'log_type': 'TRAFFIC',
                    'nat_dest': '0.0.0.0',
                    'nat_dest_port': '0',
                    'nat_source': '0.0.0.0',
                    'nat_source_port': '0',
                    'outbound_if': 'ethernet1/1',
                    'packets_received': int(in_bytes / 1500) + 1,
                    'packets_sent': int(out_bytes / 1500) + 1,
                    'protocol': props.get('ip_protocol'),
                    'rule_matched': 'Any',
                    'rule_matched_uuid': 'ce37e1dc-2ace-4425-99b8-6383ca48c765',
                    'sequence_no': seq_no,
                    'session_end_reason': 'aged-out',
                    'session_id': sess_id,
                    'severity': '1',
                    'source_device_category': '',
                    'source_device_mac': '',
                    'source_device_model': '',
                    'source_device_osfamily': '',
                    'source_device_osversion': '',
                    'source_device_profile': '',
                    'source_device_vendor': '',
                    'source_ip': props.get('src_ip'),
                    'source_port': props.get('src_port'),
                    'source_user': props.get('src_user'),
                    'subtype': 'end',
                    'time_generated': utcnow.strftime('%b %d %Y %H:%M:%S GMT'),
                    'to_zone': 'slp',
                    'total_time_elapsed': max(round(in_bytes / (1024 * 10)), 1),
                    'url_category': 'any',
                    'vsys': 'vsys1',
                    'vsys_name': '',
                    'xff_ip': '',
                }
                return LogEncoder(
                    settings=self.__settings,
                    preferred_log_format='cef',
                    preferred_syslog_header=self.__preferred_syslog_header,
                    cef_version=0,
                    cef_vendor='PANW',
                    cef_product='NGFW_CEF',
                    cef_device_version='11.1.1',
                    cef_device_event_class_id='end',
                    cef_name=f'TRAFFIC',
                    cef_severity='1',
                    log_params=exts
                )
            elif self.__log_type == 'url':
                url_comps = urllib.parse.urlparse(props.get('http.url') or '')
                app_protocol = props.get('app_protocol')
                if app_protocol == 'http':
                    uri = urllib.parse.urlunparse(
                        namedtuple('UrlComps', ['scheme', 'netloc', 'path', 'params', 'query', 'fragment'])(
                            '', url_comps.netloc, url_comps.path or '/', url_comps.params, url_comps.query, url_comps.fragment
                        )
                    ).lstrip('/')

                    exts = {
                        'referer': props.get('http.referer'),
                        'content_type': props.get('http.resp_content_type'),
                        'http_method': (props.get('http.req_method') or 'GET').lower(),
                        'uri': uri,
                        'user_agent': props.get('http.user_agent'),
                    }
                elif app_protocol == 'https':
                    exts = {
                        'referer': '',
                        'content_type': '',
                        'http_method': 'connect',
                        'uri': url_comps.netloc + '/',
                        'user_agent': '',
                    }
                else:
                    return None

                exts.update({
                    '__firewall_type': 'firewall.url',
                    '__timestamp': now.strftime('%Y/%m/%d %H:%M:%S'),
                    '__tz': now.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + local_tz,
                    'action': action,
                    'app': app,
                    'app_category': '',
                    'app_sub_category': '',
                    'dest_device_category': None,
                    'dest_device_mac': None,
                    'dest_device_model': None,
                    'dest_device_osfamily': None,
                    'dest_device_osversion': None,
                    'dest_device_profile': None,
                    'dest_device_vendor': None,
                    'dest_ip': props.get('dst_ip'),
                    'dest_port': props.get('dst_port'),
                    'dest_user': props.get('dst_user'),
                    'direction': 'client-to-server',
                    'from_zone': 'slp',
                    'http2_connection': 0,
                    'http_headers': None,
                    'inbound_if': 'ethernet1/2',
                    'log_source_id': self.__serial_no,
                    'log_source_name': 'panw-ngfw',
                    'log_time': utcnow.strftime('%b %d %Y %H:%M:%S GMT'),
                    'log_type': 'THREAT',  ## not URL
                    'nat_dest': '0.0.0.0',
                    'nat_dest_port': '0',
                    'nat_source': '0.0.0.0',
                    'nat_source_port': '0',
                    'outbound_if': 'ethernet1/1',
                    'pcap_id': 0,
                    'protocol': 'tcp',
                    'rule_matched': 'Any',
                    'rule_matched_uuid': 'fa85ca6b-e103-4c9d-bdef-73ae824e4282',
                    'sequence_no': seq_no,
                    'session_id': sess_id,
                    'severity': '1',
                    'source_device_category': '',
                    'source_device_mac': '',
                    'source_device_model': '',
                    'source_device_osfamily': '',
                    'source_device_osversion': '',
                    'source_device_profile': '',
                    'source_device_vendor': '',
                    'source_ip': props.get('src_ip'),
                    'source_port': props.get('src_port'),
                    'source_user': props.get('src_user'),
                    'subtype': 'url',
                    'threat_category': '',
                    'threat_id': '',
                    'threat_name': '',
                    'time_generated': utcnow.strftime('%b %d %Y %H:%M:%S GMT'),
                    'to_zone': 'slp',
                    'url_category': '',
                    'url_category_list': '',
                    'vsys': 'vsys1',
                    'vsys_name': '',
                    'xff': None,
                    'xff_ip': None
                })
                return LogEncoder(
                    settings=self.__settings,
                    preferred_log_format='cef',
                    preferred_syslog_header=self.__preferred_syslog_header,
                    cef_version=0,
                    cef_vendor='PANW',
                    cef_product='NGFW_CEF',
                    cef_device_version='11.1.1',
                    cef_device_event_class_id='end',
                    cef_name=f'URL',
                    cef_severity='1',
                    log_params=exts
                )
            elif self.__log_type == 'threat':
                exts = {
                    k: v if k.startswith('__') else props.get(k) or v
                    for k, v in {
                        '__firewall_type': 'firewall.threat',
                        '__timestamp': now.strftime('%Y/%m/%d %H:%M:%S'),
                        '__tz': now.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + local_tz,
                        'action': 'alert',
                        'app': 'unknown-tcp' if props.get('protocol') == 'tcp' else 'unknown-udp',
                        'app_category': '',
                        'app_sub_category': '',
                        'dest_device_category': '',
                        'dest_device_mac': '',
                        'dest_device_model': '',
                        'dest_device_osfamily': '',
                        'dest_device_osversion': '',
                        'dest_device_profile': '',
                        'dest_device_vendor': '',
                        'dest_ip': props.get('dest_ip'),
                        'dest_port': props.get('dest_port'),
                        'dest_user': props.get('dest_user'),
                        'direction': 'client-to-server',
                        'from_zone': 'slp',
                        'inbound_if': 'ethernet1/2',
                        'log_source_id': self.__serial_no,
                        'log_source_name': 'panw-ngfw',
                        'log_time': utcnow.strftime('%b %d %Y %H:%M:%S GMT'),
                        'log_type': 'THREAT',
                        'misc': '',
                        'nat_dest': '0.0.0.0',
                        'nat_dest_port': '0',
                        'nat_source': '0.0.0.0',
                        'nat_source_port': '0',
                        'outbound_if': 'ethernet1/1',
                        'protocol': 'tcp',
                        'rule_matched': 'Any',
                        'rule_matched_uuid': 'fa85ca6b-e103-4c9d-bdef-73ae824e4282',
                        'sequence_no': seq_no,
                        'session_id': sess_id,
                        'severity': '4',
                        'source_device_category': '',
                        'source_device_mac': '',
                        'source_device_model': '',
                        'source_device_osfamily': '',
                        'source_device_osversion': '',
                        'source_device_profile': '',
                        'source_device_vendor': '',
                        'source_ip': props.get('source_ip'),
                        'source_port': props.get('source_port'),
                        'source_user': props.get('source_user'),
                        'subtype': 'vulnerability',
                        'threat_category': '',
                        'threat_id': props.get('threat_id') or props.get('threat_name'),
                        'threat_name': props.get('threat_name'),
                        'time_generated': utcnow.strftime('%b %d %Y %H:%M:%S GMT'),
                        'to_zone': 'slp',
                        'user_agent': '',
                        'vsys': 'vsys1',
                        'vsys_name': '',
                        'xff': '',
                        'xff_ip': '',
                    }.items()
                }
                return LogEncoder(
                    settings=self.__settings,
                    preferred_log_format='cef',
                    preferred_syslog_header=self.__preferred_syslog_header,
                    cef_version=0,
                    cef_vendor='PANW',
                    cef_product='NGFW_CEF',
                    cef_device_version='11.1.1',
                    cef_device_event_class_id='end',
                    cef_name=f'THREAT',
                    cef_severity='4',
                    log_params=exts
                )
            else:
                raise DemistoException(f'Invalid log format type - {self.__log_type}')


    class ZscalerLogGenerator(LogGenerator):
        """ Zscaler Log Generator
        """
        def __init__(
            self,
            settings: Settings,
            log_type: str,
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            :param log_type: 'web'
            """
            if log_type not in ('web'):
                raise DemistoException(f'Invalid log type - {log_type}')

            self.__settings = settings
            self.__log_type = log_type
            self.__preferred_syslog_header = settings.syslog_preferred_headers.get('zscaler') or None

        def generate(
            self,
            props: dict[str, Any]
        ) -> LogEncoder | None:
            utcnow, now = self.__settings.log_now2()
            if self.__log_type == 'web':
                app = props.get('app_protocol')
                if app not in ('http', 'https'):
                    return None

                url = props.get('http.url') or ''
                url_comps = urllib.parse.urlparse(url)
                dhost, _, _ = url_comps.netloc.partition(':')
                src_user = props.get('src_user')
                src_domain = props.get('src_domain')
                src_upn = f'{src_user}@{src_domain}' if src_user and src_domain else None
                urlclass = 'Business Use'
                action={
                    'allow': 'Allowed',
                    'deny': 'Blocked',
                }.get(props.get('fw_action')) or 'Allowed'
                reason = action

                if any(k in url_comps.netloc for k in [
                    'www.google.', '.bing.'
                ]):
                    urlcategory = 'Web Search'
                elif 'mail.google.' in url_comps.netloc:
                    urlcategory = 'Webmail'
                elif 'maps.google.' in url_comps.netloc:
                    urlcategory = 'Reference Sites'
                elif 'docs.google.' in url_comps.netloc:
                    urlcategory = 'FileHost'
                elif 'cloudflare.com' in url_comps.netloc:
                    urlcategory = 'Professional Services'
                elif 'whatsapp.com' in url_comps.netloc:
                    urlcategory = 'Online Chat'
                elif any(k in url_comps.netloc for k in [
                    'linkedin.com', 'facebook.com'
                ]):
                    urlcategory = 'Social Networking'
                else:
                    urlcategory = 'Internet Services'

                exts = {
                    'sourcetype': 'zscalernss-web',
                    'TimeGenerated': utcnow.strftime('%Y-%m-%d %H:%M:%S'),
                    'rt': utcnow.strftime('%b %d %y %H:%M:%S'),
                    'act': action,
                    'reason': reason,
                    'app': 'HTTP_PROXY',
                    'dhost': dhost or 'None',
                    'dst': props.get('dst_ip') or 'None',
                    'src': props.get('src_ip') or 'None',
                    'sourceTranslatedAddress': props.get('src_ip') or 'None',
                    'in': int(props.get('http.req_bytes') or 0) + random.randint(128, 512),
                    'out': int(props.get('http.resp_bytes') or 0) + random.randint(128, 512),
                    'request': m[1] if (m := re.match('.*?://(.*)', url)) else 'None',
                    'requestContext': props.get('http.referer') or 'None',
                    'contenttype': props.get('http.resp_content_type') or 'None',
                    'outcome': props.get('http.resp_status') or 200,
                    'requestClientApplication': props.get('http.user_agent') or 'None',
                    'requestMethod': props.get('http.req_method') or ('GET' if app == 'http' else 'CONNECT'),
                    'suser': src_upn or 'None',
                    'spriv': 'Road Warrior',
                    'externalId': format(abs(hash(src_user or props.get('src_ip'))), '019'),
                    'fileType': 'None',
                    'destinationServiceName': 'Unknown',
                    'cat': urlcategory,
                    'deviceDirection': '1',
                    'cn1': '0',
                    'cn1Label': 'riskscore',
                    'cs1': 'Service Admin',
                    'cs1Label': 'dept',
                    'cs2': urlcategory,
                    'cs2Label': 'urlcat',
                    'cs3': 'None',
                    'cs3Label': 'malwareclass',
                    'cs4': 'None',
                    'cs4Label': 'malwarecat',
                    'cs5': 'None',
                    'cs5Label': 'threatname',
                    'cs6': 'None',
                    'cs6Label': 'md5hash',
                    'rulelabel': 'None',
                    'ruletype': 'None',
                    'urlclass': urlclass,
                    'DeviceVendor': 'Zscaler',
                    'DeviceProduct': 'NSSWeblog',
                    'flexString1': 'Unknown',
                    'flexString1Label': 'devicemodel',
                    'flexString2': 'Advanced Security Risk',
                    'flexString2Label': 'urlclass',
                    'ZscalerNSSWeblogURLClass': urlclass,
                    'devicehostname': props.get('src_host') or 'None',
                    'deviceowner': src_user or 'None',
                    'devicemodel': 'Unknown',
                    'unscannabletype': 'None',
                    'dlpdict': 'None',
                }
                return LogEncoder(
                    settings=self.__settings,
                    preferred_log_format='cef',
                    preferred_syslog_header=self.__preferred_syslog_header,
                    cef_version=0,
                    cef_vendor='Zscaler',
                    cef_product='NSSWeblog',
                    cef_device_version='5.0',
                    cef_device_event_class_id=action,
                    cef_name=reason,
                    cef_severity='3',
                    log_params=exts,
                    app_process_name='zscaler-nss',
                    app_process_id=(abs(hash('zscaler-nss')) % 10000) + 1000
                )
            else:
                raise DemistoException(f'Invalid log type - {self.__log_type}')


    class SquidLogGenerator(LogGenerator):
        """ Squid Log Generator
        """
        def __init__(
            self,
            settings: Settings,
            format_type: str
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            :param format_type: 'squid', common' or 'combined'
            """
            self.__settings = settings
            self.__format_type = format_type
            self.__preferred_syslog_header = settings.syslog_preferred_headers.get('squid') or None

        def generate(
            self,
            props: dict[str, Any]
        ) -> LogEncoder | None:
            if self.__format_type == 'squid':
                template = '%ts.%03tu %6tr %>a %Ss/%03>Hs %<st %rm %ru %[un %Sh/%<a %mt'
            elif self.__format_type == 'common':
                template = '%>a - %[un [%tl] "%rm %ru HTTP/%rv" %>Hs %<st %Ss:%Sh'
            elif self.__format_type == 'combined':
                template = '%>a - %[un [%tl] "%rm %ru HTTP/%rv" %>Hs %<st "%{Referer}>h" "%{User-Agent}>h" %Ss:%Sh'
            else:
                raise DemistoException(f'Invalid log format type - {self.__format_type}')

            now = self.__settings.log_now()
            url = props.get('http.url') or ''
            url_comps = urllib.parse.urlparse(url)
            app = props.get('app_protocol')
            if app == 'https':
                url = url_comps.netloc.split(':')[0] + ':' + str(props.get('dst_port') or '0')
                m = {
                    '%ts.%03tu': f'{now.timestamp():.3f}',
                    '%6tr': str(max(round(int(props.get('http.resp_bytes') or 0) / (1024 * 10)), 1)).rjust(6),
                    '%>a': props.get('src_ip') or '-',
                    '%Ss': 'TCP_MISS',
                    '%03>Hs': format(int(200 if (x := props.get('http.resp_status')) is None else x), '03'),
                    '%<st': props.get('http.resp_bytes') or 0,
                    '%rm': 'CONNECT',
                    '%ru': url or '-',
                    '%[un': props.get('src_user') or '-',
                    '%Sh': 'HIER_DIRECT',
                    '%<a': props.get('dst_ip') or '-',
                    '%mt': '-',
                    '%tl': now.strftime('%d/%b/%Y:%H:%M:%S %z'),
                    '%rv': (props.get('http.req_version') or '1.0').split('/')[-1],
                    '%>Hs': 200 if (x := props.get('http.resp_status')) is None else x,
                    '%{Referer}>h': '-',
                    '%{User-Agent}>h': '-',
                }
            else:
                m = {
                    '%ts.%03tu': f'{now.timestamp():.3f}',
                    '%6tr': str(max(round(int(props.get('http.resp_bytes') or 0) / (1024 * 10)), 1)).rjust(6),
                    '%>a': props.get('src_ip') or '-',
                    '%Ss': 'TCP_MISS',
                    '%03>Hs': format(int(200 if (x := props.get('http.resp_status')) is None else x), '03'),
                    '%<st': props.get('http.resp_bytes') or 0,
                    '%rm': props.get('http.req_method') or 'GET',
                    '%ru': url or '-',
                    '%[un': props.get('src_user') or '-',
                    '%Sh': 'HIER_DIRECT',
                    '%<a': props.get('dst_ip') or '-',
                    '%mt': props.get('http.resp_content_type') or '-',
                    '%tl': now.strftime('%d/%b/%Y:%H:%M:%S %z'),
                    '%rv': (props.get('http.req_version') or '1.0').split('/')[-1],
                    '%>Hs': 200 if (x := props.get('http.resp_status')) is None else x,
                    '%{Referer}>h': props.get('http.referer') or '-',
                    '%{User-Agent}>h': props.get('http.user_agent') or '-',
                }

            regex = '|'.join([re.escape(x) for x in m.keys()])
            log = re.sub(regex, lambda x: str(m[x[0]]), template)

            return LogEncoder(
                settings=self.__settings,
                preferred_log_format='raw',
                preferred_syslog_header=self.__preferred_syslog_header,
                cef_version=0,
                cef_vendor='squid',
                cef_product='squid',
                cef_device_version='1.0',
                cef_device_event_class_id='0',
                cef_name=f'access',
                cef_severity='0',
                log_params=log,
                app_process_name='squid',
                app_process_id=(abs(hash('squid')) % 10000) + 1000
            )


    class ApacheHttpdLogGenerator(LogGenerator):
        """ Apache HTTPd Log Generator
        """
        def __init__(
            self,
            settings: Settings,
            format_type: str
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            :param format_type: 'common' or 'combined'
            """
            self.__settings = settings
            self.__format_type = format_type
            self.__preferred_syslog_header = settings.syslog_preferred_headers.get('apache-httpd') or None

        def generate(
            self,
            props: dict[str, Any]
        ) -> LogEncoder | None:
            if self.__format_type == 'common':
                template = '%h %l %u %t "%r" %>s %b "%{Referer}i" "%{User-agent}i"'
            elif self.__format_type == 'combined':
                template = '%h %l %u %t "%r" %>s %b'
            else:
                raise DemistoException(f'Invalid log format type - {self.__format_type}')

            url_comps = urllib.parse.urlparse(props.get('http.url') or '')
            m = {
                '%h': props.get('src_ip') or '-',
                '%l': '-',
                '%u': props.get('src_user') or '-',
                '%t': self.__settings.log_now().strftime('[%d/%b/%Y:%H:%M:%S %z]'),
                '%r': f'{props.get("http.req_method")} {url_comps.path} {props.get("http.req_version")}',
                '%>s': props.get('http.resp_status', 200),
                '%b': props.get('http.resp_bytes') or 0,
                '%{Referer}i': props.get('http.referer') or '-',
                '%{User-agent}i': props.get('http.user_agent') or '-',
            }
            regex = '|'.join([re.escape(x) for x in m.keys()])
            log = re.sub(regex, lambda x: str(m[x[0]]), template)

            return LogEncoder(
                settings=self.__settings,
                preferred_log_format='raw',
                preferred_syslog_header=self.__preferred_syslog_header,
                cef_version=0,
                cef_vendor='apache',
                cef_product='httpd',
                cef_device_version='0',
                cef_device_event_class_id='0',
                cef_name=f'access',
                cef_severity='0',
                log_params=log,
                app_process_name='httpd',
                app_process_id=(abs(hash('httpd')) % 10000) + 1000
            )


    class BindLogGenerator(LogGenerator):
        """ BIND Log Generator
        """
        def __init__(
            self,
            settings: Settings,
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            """
            self.__settings = settings
            self.__preferred_syslog_header = settings.syslog_preferred_headers.get('bind') or None

        def generate(
            self,
            props: dict[str, Any]
        ) -> LogEncoder | None:
            server_ip = props.get('dst_ip')
            client_ip = props.get('src_ip')
            client_port = props.get('src_port') or random.randint(10000, 65534)
            client_id = hashlib.sha256(client_ip.encode()).hexdigest()[0:12]
            dns_class = props.get('dns.query_class') or 'IN'
            dns_type = props.get('dns.query_type') or 'A'
            dns_name = props.get('dns.query_name')
            log_time = self.__settings.log_now().strftime('%d-%b-%Y %H:%M:%S.%f')[:-3]
            log = (
                f'{log_time} queries: info: client @0x{client_id} {client_ip}#{client_port}'
                f' ({dns_name}): query: {dns_name} {dns_class} {dns_type} +E(0) ({server_ip})'
            )
            return LogEncoder(
                settings=self.__settings,
                preferred_log_format='raw',
                preferred_syslog_header=self.__preferred_syslog_header,
                cef_version=0,
                cef_vendor='isc',
                cef_product='bind',
                cef_device_version='0',
                cef_device_event_class_id='0',
                cef_name=f'query',
                cef_severity='0',
                log_params=log,
                app_process_name='named',
                app_process_id=(abs(hash('named')) % 10000) + 1000
            )


    class WindowsDHCPLogGenerator(LogGenerator):
        """ Windows DHCP Log Generator
        """
        def __init__(
            self,
            settings: Settings,
            host_ip: str | None,
            host_name: str | None,
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            :param host_ip: The IP address of the DHCP server.
            :param host_name: The host name of the DHCP server.
            """
            self.__settings = settings
            self.__host_ip = host_ip
            self.__host_name = host_name
            self.__preferred_syslog_header = settings.syslog_preferred_headers.get('windows-dhcp') or None

        def generate(
            self,
            props: dict[str, Any]
        ) -> LogEncoder | None:
            action = props.get('action')
            exts = {
                'assign': {
                    'id': '10',
                    'description': 'Assign',
                    'qResult': '0',
                    'transactionID': ''.join(random.choices(string.digits, k=10)),
                    'macAddress': (props.get('src_mac') or '').replace(':', ''),
                },
                'renew': {
                    'id': '11',
                    'description': 'Renew',
                    'qResult': '0',
                    'transactionID': ''.join(random.choices(string.digits, k=10)),
                    'macAddress': (props.get('src_mac') or '').replace(':', ''),
                },
                'update-request': {
                    'id': '30',
                    'qResult': '6',
                    'description': 'DNS Update Request',
                    'transactionID': '',
                    'macAddress': '',
                },
            }.get(action)

            if not exts:
                raise DemistoException(f'Invalid action type - {action}')

            now = self.__settings.log_now()
            tz = now.strftime('%z')
            exts.update({
                'date': now.strftime('%m/%d/%y'),
                'time': now.strftime('%H:%M:%S'),
                'dhcid': '',
                'hostName': props.get('src_fqdn') or '',
                'timezone': f'{tz[:3]}:{tz[3:]}',
                'userName': '',
                'ipAddress': props.get('src_ip') or '',
                'dnsRegError': '0',
                'userClassHex': '',
                'correlationID': '',
                'probationTime': '',
                'userClassASCII': '',
                'vendorClassHex': '0x4D53465420352E30',
                'vendorClassASCII': 'MSFT 5.0',
                'relayAgentInformation': ''
            })
            if fb_host := assign_params(
                hostname=self.__host_name,
                ip=self.__host_ip,
            ):
                # Metadata for filebeat collections
                exts['fb_host'] = fb_host

            return LogEncoder(
                settings=self.__settings,
                preferred_log_format='cef',
                preferred_syslog_header=self.__preferred_syslog_header,
                cef_version=0,
                cef_vendor='Microsoft',
                cef_product='DHCP',
                cef_device_version='MS-DHCP',
                cef_device_event_class_id='0',
                cef_name=f'DHCP',
                cef_severity='informational',
                log_params=exts
            )


    class WindowsEventLogGenerator(LogGenerator):
        """ Windows Event Log Generator
        """
        def __init__(
            self,
            settings: Settings,
            log_type: str
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            :param log_type: 'ad'
            """
            if log_type not in ('ad'):
                raise DemistoException(f'Invalid log type - {log_type}')

            self.__settings = settings
            self.__log_type = log_type
            self.__seq_no = int(hash(time.time()) % 10000)

        def generate(
            self,
            props: dict[str, Any]
        ) -> LogEncoder | None:
            utcnow = datetime.datetime.now(datetime.UTC)

            if self.__log_type == 'ad':
                event_id = props.get('event_id')
                match str(event_id):
                    case '4768':
                        src_user = props.get('src_user') or ''
                        if src_ip := (props.get('src_ip') or ''):
                            src_ip = f'::ffff:{src_ip}'
                        src_domain = props.get('src_domain') or ''
                        src_port = str(props.get('src_port') or '')
                        dst_host = props.get('dst_host')

                        target_sid = f'S-1-5-21-3732386465-1093955160-3641126785-{str(abs(hash(src_user)) % 7777)}'
                        service_sid = f'S-1-5-21-3732386465-1093955160-3641126785-{str(abs(hash(src_user)) % 666)}'
                        event_result = props.get('event_result')
                        status = {
                            'success': '0x0',
                            'failure': '0x18'
                        }.get(event_result) or ''
                        keywords = {
                            'success': ['Audit Success'],
                            'failure': ['Audit Failure']
                        }.get(event_result) or []

                        record_id = self.__seq_no
                        self.__seq_no += 1

                        message = (
                            'A Kerberos authentication ticket (TGT) was requested.'
                            '\n\n'
                            'Account Information:'
                            '\n\t'
                            'Account Name:'
                            '\t\t'
                            f'{src_user}'
                            '\n\t'
                            'Supplied Realm Name:'
                            '\t'
                            f'{src_domain}'
                            '\n\t'
                            'User ID:'
                            '\t\t\t'
                            f'{target_sid}'
                            '\n\n'
                            'Service Information:'
                            '\n\t'
                            'Service Name:'
                            '\t\t'
                            'krbtgt'
                            '\n\t'
                            'Service ID:'
                            '\t\t'
                            f'{service_sid}'
                            '\n\n'
                            'Network Information:'
                            '\n\t'
                            'Client Address:'
                            '\t\t'
                            f'{src_ip}'
                            '\n\t'
                            'Client Port:'
                            '\t\t'
                            f'{src_port}'
                            '\n\n'
                            'Additional Information:'
                            '\n\t'
                            'Ticket Options:'
                            '\t\t'
                            '0x40810010'
                            '\n\t'
                            'Result Code:'
                            '\t\t'
                            f'{status}'
                            '\n\t'
                            'Ticket Encryption Type:'
                            '\t'
                            '0x12'
                            '\n\t'
                            'Pre-Authentication Type:'
                            '\t'
                            '2'
                            '\n\n'
                            'Certificate Information:'
                            '\n\t'
                            'Certificate Issuer Name:'
                            '\t\t\n\t'
                            'Certificate Serial Number:'
                            '\t\n\t'
                            'Certificate Thumbprint:'
                            '\t\t\n\n'
                            'Certificate information is only provided if a certificate was used for pre-authentication.'
                            '\n\n'
                            'Pre-authentication types, ticket options, encryption types and result codes are defined in RFC 4120.'
                        )

                        params = {
                            'activity_id': None,
                            'channel': 'Security',
                            'computer_name': None,
                            'event_action': 'Kerberos Authentication Service',
                            'event_data': {
                                'PreAuthType': '2',
                                'TicketOptions': '0x40810010',
                                'Status': status,
                                'TargetUserName': src_user,
                                'ServiceName': 'krbtgt',
                                'TicketEncryptionType': '0x12',
                                'TargetDomainName': src_domain,
                                'IpAddress': src_ip or '',
                                'IpPort': src_port,
                                'TargetSid': target_sid,
                                'ServiceSid': service_sid
                            },
                            'event_id': int(event_id),
                            'event_result': event_result,
                            'host_name': dst_host,
                            'keywords': keywords,
                            'log_level': 'information',
                            'message': message,
                            'op_code': None,
                            'opcode': 'Info',
                            'os_subtype': None,
                            'process_cmd': None,
                            'process_md5': None,
                            'process_name': None,
                            'process_path': None,
                            'process_pid': 656,
                            'process_sha256': None,
                            'process_thread_id': 3180,
                            'provider_guid': '{54849625-5478-4994-a5ba-3e3b0328c30d}',
                            'provider_name': 'Microsoft-Windows-Security-Auditing',
                            'record_id': record_id,
                            'task': 'Kerberos Authentication Service',
                            'time_created': utcnow.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z',
                            'user': None,
                            'user_data': None,
                            'version': None
                        }

                        event = dict(props.get('event') or {})
                        if event_data := event.pop('event_data', None):
                            params['event_data'].update(event_data)
                        params.update(event)

                        return LogEncoder(
                            settings=self.__settings,
                            preferred_log_format='microsoft-windows-json',
                            preferred_syslog_header=(
                                self.__settings.syslog_preferred_headers.get('windows-event-ad') or None
                            ),
                            cef_version=0,
                            cef_vendor='Microsoft',
                            cef_product='Windows',
                            cef_device_version='1.0',
                            cef_device_event_class_id=event_id,
                            cef_name=f'event_log',
                            cef_severity='1',
                            log_params=params
                        )

                    case _:
                        return None

            else:
                raise DemistoException(f'Invalid log type - {self.__log_type}')


    class CustomLogGenerator(LogGenerator):
        """ Custom Log Generator
        """
        def __init__(
            self,
            settings: Settings,
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            """
            self.__settings = settings
            self.__preferred_syslog_header = settings.syslog_preferred_headers.get('custom') or None

        def generate(
            self,
            props: dict[str, Any]
        ) -> LogEncoder | None:
            log_format = (props.get('log_format') or 'cef').lower()
            log_params = props.get('log_params') or {}
            if log_format not in ('raw', 'cef', 'json'):
                raise DemistoException(f'Invalid log format - {log_format}')

            if log_format == 'raw':
                log_params = props.get('log_params') or ''
                if not isinstance(log_params, str):
                    log_params = json.dumps(log_params)
            else:
                log_params = props.get('log_params') or {}

            return LogEncoder(
                settings=self.__settings,
                preferred_log_format=log_format,
                preferred_syslog_header=self.__preferred_syslog_header,
                cef_version=props.get('cef_version') or '0',
                cef_vendor=props.get('cef_vendor') or 'unknown',
                cef_product=props.get('cef_product') or 'unknown',
                cef_device_version=props.get('cef_device_version') or '1.0',
                cef_device_event_class_id=props.get('cef_device_event_class_id') or 'unknown',
                cef_name=props.get('cef_name') or 'unknown',
                cef_severity=props.get('cef_severity') or '0',
                log_params=log_params
            )


    class LogPropertiesGenerator:
        """ This class generates meta data for logs.
        """
        def __init__(
            self,
            ip_entries: IpEntries
        ) -> None:
            """ Initialize the instance

            :param ip_entries: The users manager.
            """
            self.__ip_ents = ip_entries

        def __choose_candidate_ip(
            self,
            config: str | list[str | ipaddress.IPv4Network]
        ) -> ipaddress.IPv4Network | str:
            """ Choose an IP network to generate an IP.

            :param config: The settings to generate an IP.
            :return: An IP network picked from the config.
            """
            if isinstance(config, str):
                return self.__choose_candidate_ip(argToList(config))
            elif isinstance(config, list):
                ip_network = random.choice(config)
                if isinstance(ip_network, str) and ',' in ip_network:
                    return self.__choose_candidate_ip(argToList(ip_network))
                else:
                    return ip_network
            else:
                raise DemistoException(f'Invalid config for IP generation - {config}')

        def __generate_ip(
            self,
            config: str | list[str | ipaddress.IPv4Network]
        ) ->  str:
            """ Generate an IP address

            :param config: The settings to generate an IP.
            :return: An IP address generated.
            """
            ip_network = self.__choose_candidate_ip(config)
            if isinstance(ip_network, str):
                if ip_network == 'public':
                    privates = (
                        ipaddress.IPv4Network('10.0.0.0/8'),
                        ipaddress.IPv4Network('172.16.0.0/12'),
                        ipaddress.IPv4Network('192.168.0.0/16'),
                        ipaddress.IPv4Network('127.0.0.0/8'),
                        ipaddress.IPv4Network('169.254.0.0/16'),
                        ipaddress.IPv4Network('100.64.0.0/10'),
                    )
                    ip = ipaddress.IPv4Address(
                        next(filter(
                            lambda ip: ip not in privates,
                            iter(lambda: random.randint(0, 0xffffffff), None)
                        ))
                    )
                    return str(ip)
                else:
                    ip_network = ipaddress.IPv4Network(ip_network, False)

            while True:
                ip = ipaddress.IPv4Address(
                    (random.randint(0, 0xffffffff) & int(ip_network.hostmask))
                    |
                    int(ip_network.network_address)
                )
                if (
                    ip_network.num_addresses <= 2 or
                    ip not in (ip_network.network_address, ip_network.broadcast_address)
                ):
                    return str(ip)

        def __extract_ports(
            self,
            config: str | list[str | int]
        ) -> set[int]:
            """ Extract port numbers

            :param config: The settings to generate a port number.
            :return: All candidate port numbers.
            """
            if isinstance(config, str):
                return self.__extract_ports(argToList(config))
            elif isinstance(config, list):
                ports = set()
                for ent in config:
                    if isinstance(ent, int):
                        ports.add(ent)
                    elif ',' in ent:
                        ports |= self.__generate_port(argToList(ent))
                    elif m := re.fullmatch(r'(\d+)-(\d+)$', ent):
                        port1, port2 = sorted([
                            min(max(int(m[1]), 0), 65535),
                            min(max(int(m[2]), 0), 65535)
                        ])
                        ports |= set(range(port1, port2 + 1))
                    else:
                        ports.add(int(ent))
                return ports
            else:
                raise DemistoException(f'Invalid config for port number generation - {config}')

        def __generate_port(
            self,
            config: int | str | list[str | int]
        ) -> str:
            """ Generate a port number

            :param config: The settings to generate a port number.
            :return: A port number generated.
            """
            if isinstance(config, int):
                return config
            if isinstance(config, str):
                ports = self.__extract_ports(argToList(config))
                return random.choice(list(ports))
            elif isinstance(config, list):
                port = random.choice(config)
                if isinstance(port, int):
                    return port
                else:
                    ports = self.__extract_ports(port)
                    return random.choice(list(ports))
            else:
                raise DemistoException(f'Invalid config for port number generation - {config}')

        def __generate_http(
            self,
            http: dict[str, Any]
        ) -> dict[str, Any] | None:
            """ Generate a HTTP session parameters

            :param http: The 'http' section of the template parameters.
            :return: HTTP session parameters.
            """
            if not (dst := toList(demisto.get(http, 'dst'))):
                return None

            weights = [max(float(x.get('.weights') or 1), 0) if isinstance(x, dict) else 1 for x in dst]
            dst = random.choices(dst, weights)[0]
            if isinstance(dst, str):
                dst = {'url': dst}

            params = {
                'http.url': dst.get('url') or '',
                'http.req_method': (
                    dst.get('req_method') or demisto.get(http, 'default.req_method') or 'GET'
                ),
                'http.req_version': (
                    dst.get('req_version') or demisto.get(http, 'default.req_version') or 'HTTP/1.0'
                ),
                'http.req_bytes': (
                    dst.get('req_bytes') or demisto.get(http, 'default.req_bytes') or '0'
                ),
                'http.resp_status': (
                    dst.get('resp_status') or demisto.get(http, 'default.resp_status') or '200'
                ),
                'http.user_agent': (
                    dst.get('user_agent') or demisto.get(http, 'default.user_agent')
                ),
                'http.referer': (
                    dst.get('referer') or demisto.get(http, 'default.referer')
                ),
                'http.resp_bytes': (
                    dst.get('resp_bytes') or demisto.get(http, 'default.resp_bytes') or '0'
                ),
                'http.resp_content_type': (
                    dst.get('resp_content_type') or demisto.get(http, 'default.resp_content_type')
                )
            }
            if not params.get('http.resp_content_type'):
                _, ext = os.path.splitext(urllib.parse.urlparse(params.get('url')).path)
                if mime_type := FILE_EXTENSION_TO_MIME_TYPE.get(ext):
                    params['http.resp_content_type'] = mime_type
            return params

        def __generate_dns(
            self,
            dns: dict[str, Any]
        ) -> dict[str, Any] | None:
            """ Generate a DNS session parameters

            :param dns: The 'dns' section of the template parameters.
            :return: DNS session parameters.
            """
            if not (queries := toList(demisto.get(dns, 'queries'))):
                return None

            weights = [max(float(x.get('.weights') or 1), 0) if isinstance(x, dict) else 1 for x in queries]
            query = random.choices(queries, weights)[0]
            if isinstance(query, str):
                query = {'name': query}

            params = {
                'dns.query_name': query.get('name') or '',
                'dns.query_class': query.get('class') or 'IN',
                'dns.query_type': query.get('type') or 'A',
            }
            return params

        def __generate_mac(
            self,
            config: str | list[str] | None
        ) ->  str:
            """ Generate a MAC address

            :param config: The settings to generate a MAC address.
            :return: A MAC address generated.
            """
            if not config:
                return f'02:00:00:{random.randint(0, 255):02x}:{random.randint(0, 255):02x}:{random.randint(0, 255):02x}'
            elif isinstance(config, str):
                return config
            else:
                return random.choice(config)

        async def generate_network(
            self,
            template: dict[str, Any]
        ) -> dict[str, Any]:
            """ Generate network log properties for a log message

            :param template: The template parameters.
            :return: log properties generated from the template.
            """
            _type = template.get('type')
            if _type != 'network':
                raise DemistoException(f'Template type is not network - {_type}')

            http_props = self.__generate_http(template.get('http') or {}) or {}

            x = self.__choose_candidate_ip(template.get('dst') or 'public')
            if isinstance(x, str) and x in ('realip-by-http.dst', 'realip-by-http.dst-if-possible'):
                dst_ip = await GetHostByName(
                    urllib.parse.urlparse(http_props.get('http.url') or '').netloc,
                    None if x == 'realip-by-http.dst' else self.__generate_ip('public')
                ).resolve_ip()
            else:
                dst_ip = self.__generate_ip(x)

            props = {
                'src_ip': self.__generate_ip(
                    template.get('src') or 'public'
                ),
                'src_port': self.__generate_port(
                    template.get('src_port') or '10000-65534'
                ),
                'dst_ip': dst_ip,
                'dst_port': self.__generate_port(
                    template.get('dst_port') or '10000-65534'
                ),
                'ip_protocol': template.get('ip_protocol') or 'tcp',
                'app_protocol': template.get('app_protocol') or '',
                'fw_action': template.get('fw_action') or 'allow',
            }
            props.update(assign_params(
                src_user=(
                    template.get('src_user') or self.__ip_ents.get_user_id_by_ip(props.get('src_ip'))
                    if 'src_user' in template else None
                ),
                src_domain=(
                    template.get('src_domain') or self.__ip_ents.get_domain_by_ip(props.get('src_ip'))
                    if 'src_domain' in template else None
                ),
                src_host=(
                    template.get('src_host') or self.__ip_ents.get_host_by_ip(props.get('src_ip'))
                    if 'src_host' in template else None
                ),
                dst_user=(
                    template.get('dst_user') or self.__ip_ents.get_user_id_by_ip(props.get('dst_ip'))
                    if 'dst_user' in template else None
                ),
                dst_domain=(
                    template.get('dst_domain') or self.__ip_ents.get_domain_by_ip(props.get('dst_ip'))
                    if 'dst_domain' in template else None
                ),
                dst_host=(
                    template.get('dst_host') or self.__ip_ents.get_host_by_ip(props.get('dst_ip'))
                    if 'dst_host' in template else None
                ),
            ))
            props.update(http_props)
            props.update(self.__generate_dns(template.get('dns') or {}) or {})
            return props

        def generate_dhcp(
            self,
            template: dict[str, Any]
        ) -> dict[str, Any]:
            """ Generate DHCP log properties for a log message

            :param template: The template parameters.
            :return: log properties generated from the template.
            """
            _type = template.get('type')
            if _type != 'dhcp':
                raise DemistoException(f'Template type is not dhcp - {_type}')

            props = {
                'src_ip': self.__generate_ip(
                    template.get('src_ip') or 'public'
                ),
                'src_port': self.__generate_port(
                    template.get('src_port') or '10000-65534'
                ),
                'src_mac': self.__generate_mac(
                    template.get('src_mac')
                ),
                'action': template.get('action') or 'assign',
            }
            props['src_fqdn'] = (
                template.get('src_fqdn') or
                self.__ip_ents.get_fqdn_by_ip(props.get('src_ip'))
            )
            props.update(assign_params(
                src_user=(
                    template.get('src_user') or self.__ip_ents.get_user_id_by_ip(props.get('src_ip'))
                    if 'src_user' in template else None
                )
            ))
            return props

        def generate_ngfw_threat(
            self,
            template: dict[str, Any]
        ) -> dict[str, Any]:
            """ Generate NGFW threat log properties for a log message

            :param template: The template parameters.
            :return: log properties generated from the template.
            """
            _type = template.get('type')
            if _type != 'ngfw-threat':
                raise DemistoException(f'Template type is not ngfw-threat - {_type}')

            props = template.get('params') or {}
            props.update(assign_params(
                source_ip=self.__generate_ip(
                    props.get('source_ip') or 'public'
                ),
                source_port=self.__generate_port(
                    props.get('source_port') or '10000-65534'
                ),
                dest_ip=self.__generate_ip(
                    self.__choose_candidate_ip(props.get('dest_ip') or 'public')
                ),
                dest_port=self.__generate_port(
                    props.get('dest_port') or '10000-65534'
                ),
            ))
            props.update(assign_params(
                source_user=(
                    props.get('source_user') or self.__ip_ents.get_user_id_by_ip(props.get('source_ip'))
                    if 'source_user' in props else None
                ),
                dest_user=(
                    props.get('dest_user') or self.__ip_ents.get_user_id_by_ip(props.get('dest_ip'))
                    if 'dest_user' in props else None
                )
            ))
            return props

        def generate_windows_event(
            self,
            template: dict[str, Any]
        ) -> dict[str, Any]:
            """ Generate windows event log properties for a log message

            :param template: The template parameters.
            :return: log properties generated from the template.
            """
            _type = template.get('type')
            if _type != 'windows-event-ad':
                raise DemistoException(f'Template type is not windows-event-ad - {_type}')

            props = {
                'src_ip': self.__generate_ip(
                    template.get('src_ip') or 'public'
                ),
                'src_port': self.__generate_port(
                    template.get('src_port') or '10000-65534'
                ),
                'dst_host': template.get('dst_host'),
                'event_id': template.get('event_id'),
                'event_result': template.get('event_result') or '',
                'event': template.get('event') or {},
            }
            props.update({
                'src_domain': (
                    template.get('src_domain') or
                    self.__ip_ents.get_domain_by_ip(props.get('src_ip')) or ''
                ),
                'src_user': (
                    template.get('src_user') or
                    self.__ip_ents.get_user_id_by_ip(props.get('src_ip')) or ''
                ),
            })
            return props

        def generate_custom(
            self,
            template: dict[str, Any]
        ) -> dict[str, Any]:
            """ Generate custom log properties for a log message

            :param template: The template parameters.
            :return: log properties generated from the template.
            """
            _type = template.get('type')
            if _type != 'custom':
                raise DemistoException(f'Template type is not custom - {_type}')

            props = {
                k: template.get(k, default_value)
                for k, default_value in {
                    'log_format': 'cef',
                    'cef_version': '0',
                    'cef_vendor': 'unknown',
                    'cef_product': 'unknown',
                    'cef_device_version': 'unknown',
                    'cef_device_event_class_id': 'unknown',
                    'cef_name': 'unknown',
                    'cef_severity': '0',
                    'source_hostname': None,
                    'app_process_name': None,
                    'app_process_id': None,
                    'log_params': {},
                }.items()
            }
            return props

        async def generate(
            self,
            template: dict[str, Any]
        ) -> dict[str, Any] | None:
            """ Generate log properties for a log message

            :param template: The template parameters.
            :return: log properties generated from the template.
            """
            _type = template.get('type')
            if _type is None:
                return None

            match _type:
                case 'network':
                    return await self.generate_network(template)

                case 'dhcp':
                    return self.generate_dhcp(template)

                case 'ngfw-threat':
                    return self.generate_ngfw_threat(template)

                case 'windows-event-ad':
                    return self.generate_windows_event(template)

                case 'custom':
                    return self.generate_custom(template)

                case _:
                    raise DemistoException(f'Unknown template type - {_type}')


    ''' Template CLASSES '''


    class Template:
        """ Template object
        """
        @staticmethod
        def __eval(
            value: Any,
            variables: Variables,
        ) -> Any:
            """ Run eval() for the value

            :param value: The value.
            :param variables: The local variables for eval().
            :return The output value from eval().
            """
            if isinstance(value, dict):
                return {
                    k: v if k.startswith('.') else Template.__eval(v, variables)
                    for k, v in value.items()
                }
            elif isinstance(value, list):
                return [Template.__eval(v, variables) for v in value]
            elif isinstance(value, str):
                return variables.eval_str(value)
            else:
                return value

        def __init__(
            self,
            template: dict[str, Any],
            variables: Variables,
        ) -> None:
            """ Initialize the template by replacing variables in the template except for keys starting with '.'

            :param template: The source template.
            :param variables: The variables for .
            """
            self.__template = Template.__eval(template, variables)
            self.__variables = variables

        @property
        def template(
            self
        ) -> dict[str, Any]:
            return self.__template

        @property
        def variables(
            self
        ) -> Variables:
            return self.__variables


    class SourceTemplateUnit:
        """ Source Template Unit object
        """
        @staticmethod
        def __enum_source_templates(
            source_templates: Any,
        ) -> Iterator[dict[str, Any]]:
            if isinstance(source_templates, list):
                for x in source_templates:
                    yield from SourceTemplateUnit.__enum_source_templates(x)
            elif isinstance(source_templates, dict):
                yield source_templates
            else:
                raise DemistoException('Source template must be dict or list.')

        @staticmethod
        def __enum_templates(
            source_templates: Any,
            variables: Variables,
        ) -> Iterator[Template]:
            class Repeat:
                def __init__(self) -> None:
                    self.count = 1
                    self.eval_once = False
                    self.iter_vars = None

            def __get_repeat(
                source_template: dict[str, Any],
                variables: Variables,
            ) -> Repeat:
                def __get_iter_vars(
                    val: Any,
                    variables: Variables,
                ) -> list[dict[str, Any]] | None:
                    def __enum_vars(
                        val: Any,
                        variables: Variables,
                    ) -> Iterator[dict[str, Any]]:
                        if isinstance(val, dict):
                            yield val
                        elif isinstance(val, list):
                            for v in val:
                                yield from __enum_vars(v, variables)
                        elif isinstance(val, str):
                            # Get variables from the variables
                            v = variables.get_value(val)
                            if v is None:
                                raise DemistoException(f'No values in the variables - {variables.local_vars}')
                            yield from __enum_vars(v, variables)
                        else:
                            raise DemistoException(f'variables must be str, dict or list - {val}')

                    return None if val is None else list(__enum_vars(val, variables))

                r = Repeat()
                repeat = source_template.get('.repeat')
                if repeat is not None:
                    if isinstance(repeat, dict):
                        r.eval_once = argToBoolean(
                            variables.eval_str(repeat.get('eval_once', 'false'))
                        )
                        r.iter_vars = __get_iter_vars(
                            repeat.get('iter_vars'),
                            variables
                        )
                        repeat = repeat.get('count') or 1

                r.count = max(int(variables.eval_str(repeat) or 1), 1)
                return r


            if isinstance(source_templates, list):
                for x in source_templates:
                    yield from SourceTemplateUnit.__enum_templates(x, variables)
            elif isinstance(source_templates, dict):
                if lvars := source_templates.get('.variables'):
                    variables = variables.inherit(None, lvars)

                template = None
                repeat = __get_repeat(source_templates, variables)
                for lvars in repeat.iter_vars or [None]:
                    lvars = variables.inherit(None, lvars)
                    for _ in range(repeat.count):
                        if template is None or not repeat.eval_once:
                            template = Template(source_templates, lvars)
                        yield template
            else:
                raise DemistoException('Source template must be dict or list.')

        def __init__(
            self,
            tunit: dict[str, Any] | list[dict[str, Any]],
        ) -> None:
            """ Initialize the source template unit

            :param tunit: A template source or list of template sources.
            """
            self.__source_templates = tunit if isinstance(tunit, list) else [tunit]

        def enum_source_templates(
            self,
        ) -> Iterator[dict[str, Any]]:
            """ Enumerate the source templates.

            :return: An iterator to get source templates.
            """
            yield from SourceTemplateUnit.__enum_source_templates(self.__source_templates)

        def enum_templates(
            self,
            variables: Variables,
        ) -> Iterator[Template]:
            """ Create and enumerate templates from the source templates.

            :param variables: The current variables.
            :return: An iterator to get templates.
            """
            yield from SourceTemplateUnit.__enum_templates(self.__source_templates, variables)


    class JobUnit:
        """ Job Unit object
        """
        def __init__(
            self,
            job: dict[str, Any],
            variables: Variables,
        ) -> None:
            """ Initialize the job unit

            :param job: The job unit.
            :param variables: The variables.
            """
            self.__params = job
            self.__interval = job.get('.interval') or 0
            self.__sources = [SourceTemplateUnit(s) for s in toList(demisto.get(job, 'sources'))]
            self.__variables = variables.inherit(None, job.get('.variables'))
            self.__label = job.get('#')

        @property
        def sources(
            self,
        ) -> list[SourceTemplateUnit]:
            return self.__sources

        @property
        def variables(
            self,
        ) -> Variables:
            return self.__variables

        @property
        def label(
            self,
        ) -> str | None:
            return self.__label

        def next_time(
            self,
            now: float,
        ) -> float:
            if isinstance(self.__interval, str):
                return now + float(self.__variables.eval_str(self.__interval))
            else:
                return now + float(self.__interval)


    class ServiceEntity:
        """ Service/Device Entity object
        """
        def __init__(
            self,
            settings: Settings,
            service: dict[str, Any],
        ) -> None:
            """ Initialize the service/device entity instance

            :param settings: The instance settings.
            :param service: The service entity parameters.
            """
            self.__settings = settings

            self.__ip = service.get('ip')
            self.__product = service.get('product')
            if not self.__ip or not self.__product:
                raise DemistoException('A service entity must have "ip" and "product"')

            self.__fqdn = service.get('fqdn') or None
            self.__host, _, self.__domain = (self.__fqdn or '').partition('.')
            self.__ports = [int(port) for port in argToList(service.get('port'))]
            self.__protocol = service.get('protocol') or None

            match self.__product:
                case 'checkpoint-fw':
                    self.__generators = [
                        CheckPointLogGenerator(settings, 'traffic')
                    ]

                case 'fortigate':
                    self.__generators = [
                        FortiGateLogGenerator(settings, 'traffic')
                    ]

                case 'ngfw':
                    self.__generators = [
                        NGFWLogGenerator(settings, log_type)
                        for log_type in toSet(
                            demisto.get(service, 'ngfw.log_type') or ['traffic', 'url']
                        )
                    ]

                case 'squid':
                    self.__generators = [
                        SquidLogGenerator(
                            settings,
                            log_format,
                        ) for log_format in toSet(
                            demisto.get(service, 'squid.log_format') or 'combined'
                        )
                    ]

                case 'zscaler-nssweb':
                    self.__generators = [
                        ZscalerLogGenerator(settings, 'web')
                    ]

                case 'apache-httpd':
                    self.__generators = [
                        ApacheHttpdLogGenerator(
                            settings,
                            log_format,
                        ) for log_format in toSet(
                            demisto.get(service, 'apache-httpd.log_format') or 'combined'
                        )
                    ]

                case 'bind':
                    self.__generators = [
                        BindLogGenerator(settings)
                    ]

                case 'windows-dhcp':
                    self.__generators = [
                        WindowsDHCPLogGenerator(
                            settings=settings,
                            host_ip=self.__ip,
                            host_name=self.__host or None
                        )
                    ]

                case _:
                    raise DemistoException(f'Unknown product - {self.__product}')

        @property
        def generators(
            self,
        ) -> list[LogGenerator]:
            return self.__generators

        @property
        def ip(
            self,
        ) -> str:
            return self.__ip

        @property
        def ports(
            self,
        ) -> list[int]:
            return self.__ports

        @property
        def protocol(
            self,
        ) -> str | None:
            return self.__protocol

        @property
        def fqdn(
            self,
        ) -> str | None:
            return self.__fqdn

        @property
        def host(
            self,
        ) -> str | None:
            return self.__fqdn or None

        @property
        def domain(
            self,
        ) -> str | None:
            return self.__domain or None


    class ProxyServiceEntity(ServiceEntity):
        """ Service/Device Entity object for proxy
        """
        def __init__(
            self,
            settings: Settings,
            service: dict[str, Any],
        ) -> None:
            """ Initialize the service/device entity instance

            :param settings: The instance settings.
            :param service: The service entity parameters.
            """
            super().__init__(settings, service)

            self.__rules = {
                k: [
                    ipaddress.IPv4Network(ip_network, False)
                    for ip_network in toList(demisto.get(service, f'proxy.rule.{k}'))
                ] for k in ('src', 'dst')
            }
            self.__exceptions = {
                k: [
                    ipaddress.IPv4Network(ip_network, False)
                    for ip_network in toList(demisto.get(service, f'proxy.exception.{k}'))
                ] for k in ('src', 'dst')
            }

        @property
        def rules_src(
            self,
        ) -> list[ipaddress.IPv4Network]:
            return self.__rules.get('src') or []

        @property
        def rules_dst(
            self,
        ) -> list[ipaddress.IPv4Network]:
            return self.__rules.get('dst') or []

        @property
        def exceptions_src(
            self,
        ) -> list[ipaddress.IPv4Network]:
            return self.__exceptions.get('src') or []

        @property
        def exceptions_dst(
            self,
        ) -> list[ipaddress.IPv4Network]:
            return self.__exceptions.get('dst') or []


    class DnsServiceEntity(ServiceEntity):
        """ Service/Device Entity object for DNS
        """
        def __init__(
            self,
            settings: Settings,
            service: dict[str, Any],
        ) -> None:
            """ Initialize the service/device entity instance

            :param settings: The instance settings.
            :param service: The service entity parameters.
            """
            super().__init__(settings, service)

            self.__forwarders: Tuple[str, int] = []
            for forwarder in argToList(demisto.get(service, f'dns.forwarder')):
                ip, _, port = forwarder.partition(':')
                self.__forwarders.append((ip, int(port or 53)))

        @property
        def forwarders(
            self,
        ) -> list[Tuple[str, int]]:
            return self.__forwarders


    class ServiceMap:
        """ Service/Device Map
        """
        def __init__(
            self,
            settings: Settings,
            services: dict[str, Any] = None,
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            :param services: The service map parameters.
            """
            self.__settings = settings
            self.__internal_gw_dst_ip: str | None = None
            self.__internal_tap: list[ServiceEntity] = []
            self.__internal_proxy: list[ProxyServiceEntity] = []
            self.__internal_web: list[ServiceEntity] = []
            self.__internal_dns: list[DnsServiceEntity] = []
            self.__internal_dhcp: list[ServiceEntity] = []

            self.__external_tap: list[ServiceEntity] = []
            self.__external_proxy: list[ProxyServiceEntity] = []
            self.__external_web: list[ServiceEntity] = []
            self.__external_dns: list[DnsServiceEntity] = []
            self.__external_dhcp: list[ServiceEntity] = []

            if services:
                self.update(services)

        def update(
            self,
            services: dict[str, Any],
        ) -> None:
            """ Add and update with the new service map.

            :param services: The new service map parameters.
            """
            for k, ents, creator in [
                (
                    'internal.tap',
                    self.__internal_tap,
                    lambda settings, service: ServiceEntity(settings, service)
                ),
                (
                    'internal.proxy',
                    self.__internal_proxy,
                    lambda settings, service: ProxyServiceEntity(settings, service)
                ),
                (
                    'internal.web',
                    self.__internal_web,
                    lambda settings, service: ServiceEntity(settings, service)
                ),
                (
                    'internal.dns',
                    self.__internal_dns,
                    lambda settings, service: DnsServiceEntity(settings, service)
                ),
                (
                    'internal.dhcp',
                    self.__internal_dhcp,
                    lambda settings, service: ServiceEntity(settings, service)
                ),
                (
                    'external.tap',
                    self.__external_tap,
                    lambda settings, service: ServiceEntity(settings, service)
                ),
                (
                    'external.proxy',
                    self.__external_proxy,
                    lambda settings, service: ProxyServiceEntity(settings, service)
                ),
                (
                    'external.web',
                    self.__external_web,
                    lambda settings, service: ServiceEntity(settings, service)
                ),
                (
                    'external.dns',
                    self.__external_dns,
                    lambda settings, service: DnsServiceEntity(settings, service)
                ),
                (
                    'external.dhcp',
                    self.__external_dhcp,
                    lambda settings, service: ServiceEntity(settings, service)
                ),
            ]:
                ents.extend([
                    creator(self.__settings, s)
                    for s in toList(demisto.get(services, k))
                ])

            self.__internal_gw_dst_ip = demisto.get(services, 'internal.gw.dst_ip')

        @property
        def internal_gw_dst_ip(
            self,
        ) -> str | None:
            return self.__internal_gw_dst_ip

        @property
        def internal_tap(
            self,
        ) -> list[ServiceEntity]:
            return self.__internal_tap

        @property
        def internal_proxy(
            self,
        ) -> list[ProxyServiceEntity]:
            return self.__internal_proxy

        @property
        def internal_web(
            self,
        ) -> list[ServiceEntity]:
            return self.__internal_web

        @property
        def internal_dns(
            self,
        ) -> list[DnsServiceEntity]:
            return self.__internal_dns

        @property
        def internal_dhcp(
            self,
        ) -> list[ServiceEntity]:
            return self.__internal_dhcp

        @property
        def external_tap(
            self,
        ) -> list[ServiceEntity]:
            return self.__external_tap

        @property
        def external_proxy(
            self,
        ) -> list[ProxyServiceEntity]:
            return self.__external_proxy

        @property
        def external_web(
            self,
        ) -> list[ServiceEntity]:
            return self.__external_web

        @property
        def external_dns(
            self,
        ) -> list[DnsServiceEntity]:
            return self.__external_dns

        @property
        def external_dhcp(
            self,
        ) -> list[ServiceEntity]:
            return self.__external_dhcp


    class ScenarioStruct:
        """ Scenario JSON Structure
        """
        def __init__(
            self,
        ) -> None:
            """ Initialize the scenario.
            """
            self.__variables: dict[str, Any] = {}
            self.__sources: list[dict[str, Any]] = []
            self.__jobs: list[dict[str, Any]] = []
            self.__ip_ents: dict[str, dict[str, str]] = {}
            self.__services: dict[
                str,
                dict[
                    str,
                    list[dict[str, Any]]
                ]
            ] = defaultdict(lambda: defaultdict(list))

        def update(
            self,
            scenario: dict[str, Any],
        ) -> None:
            """ Add and update with the new scenario.

            :param scenario: A new scenario in JSON.
            """
            self.__variables.update(scenario.get('variables') or {})
            self.__sources.extend([x for x in toList(demisto.get(scenario, 'sources'))])
            self.__jobs.extend([x for x in toList(demisto.get(scenario, 'jobs'))])
            self.__ip_ents.update(scenario.get('ip_entries') or {})

            services = scenario.get('services') or {}
            for location in ['internal', 'external']:
                for service_type in ['tap', 'proxy', 'web', 'dns', 'dhcp']:
                    dst = toList(demisto.get(self.__services, f'{location}.{service_type}'))
                    src = toList(demisto.get(services, f'{location}.{service_type}'))
                    dst.extend(src)
                    if dst:
                        self.__services[location][service_type] = dst

            if gw := demisto.get(services, f'internal.gw'):
                self.__services['internal']['gw'] = gw

        def build(
            self
        ) -> dict[str, Any]:
            """ Build a scenario dictionary.

            :return: The scenario in JSON.
            """
            return {
                'variables': self.__variables,
                'sources': self.__sources,
                'jobs': self.__jobs,
                'services': self.__services,
                'ip_entries': self.__ip_ents,
            }

        @property
        def variables(
            self
        ) -> dict[str, Any]:
            return self.__variables

        @property
        def sources(
            self
        ) -> list[dict[str, Any]]:
            return self.__sources

        @property
        def jobs(
            self
        ) -> list[dict[str, Any]]:
            return self.__jobs

        @property
        def services(
            self
        ) -> dict[str, Any]:
            return self.__services

        @property
        def ip_entries(
            self
        ) -> dict[str, dict[str, str]]:
            return self.__ip_ents


    class DefaultScenario:
        """ Scenario JSON Structure
        """
        SCENARIO_NORMAL = r'''
    {
        ".variables": {
        },
        "sources": [
            {
                "operation": "internal.outbound",
                "type": "network",
                "src": "172.16.77.0/24",
                "src_user": null,
                "src_host": null,
                "src_domain": null,
                "dst": "realip-by-http.dst-if-possible",
                "dst_port": 80,
                "ip_protocol": "tcp",
                "app_protocol": "http",
                "fw_action": "allow",
                "http": {
                    "default": {
                        "user_agent": "Windows-Update-Agent/923.614.111.0 Client-Protocol/2.71",
                        "req_method": "GET",
                        "req_version": "HTTP/1.1",
                        "resp_status": 200,
                        "resp_bytes": "{random.randint(376, 1024 * 1024)}"
                    },
                    "dst": [
                        "http://download.windowsupdate.com/d/msdownload/update/others/{datetime.datetime.now().year}/{datetime.datetime.now().month}/{''.join(random.choices(string.hexdigits, k=8))}_{''.join(random.choices(string.hexdigits, k=40))}.cab"
                    ]
                },
                ".weights": 100
            },
            {
                "operation": "internal.outbound",
                "type": "network",
                "src": "172.16.77.0/24",
                "src_user": null,
                "src_host": null,
                "src_domain": null,
                "dst": "realip-by-http.dst-if-possible",
                "dst_port": 443,
                "ip_protocol": "tcp",
                "app_protocol": "https",
                "fw_action": "allow",
                "http": {
                    "default": {
                        "resp_status": 200,
                        "resp_bytes": "{random.randint(512, 256 * 1024)}"
                    },
                    "dst": [
                        "https://apis.google.com/",
                        "https://clients2.google.com/",
                        "https://fonts.googleapis.com/",
                        "https://global-content-profiles-policy.storage.googleapis.com/",
                        "https://ogads-pa.googleapis.com/",
                        "https://ogs.google.co.jp/",
                        "https://panw-xdr-installers-prod-us.storage.googleapis.com/",
                        "https://play.google.com/",
                        "https://safebrowsing.googleapis.com/",
                        "https://sb-ssl.google.com/",
                        "https://storage.googleapis.com/",
                        "https://update.googleapis.com/",
                        "https://www.google-analytics.com/",
                        "https://www.googleadservices.com/",
                        "https://www.googleapis.com/",
                        "https://www.googletagmanager.com/",
                        {
                            "url": "https://www.google.co.jp/",
                            ".weights": 5
                        },
                        {
                            "url": "https://www.google.com/",
                            ".weights": 10
                        }
                    ]
                },
                ".weights": 200
            },
            {
                "operation": "internal.outbound",
                "type": "network",
                "src": "172.16.77.0/24",
                "src_user": null,
                "src_host": null,
                "src_domain": null,
                "dst": "realip-by-http.dst-if-possible",
                "dst_port": 443,
                "ip_protocol": "tcp",
                "app_protocol": "https",
                "fw_action": "allow",
                "http": {
                    "default": {
                        "resp_status": 200,
                        "resp_bytes": "{random.randint(512, 256 * 1024)}"
                    },
                    "dst": [
                        "https://a-ring.msedge.net/",
                        "https://a.popin.cc/",
                        "https://aadcdn.msauth.net/",
                        "https://acdc-direct.office.com/",
                        "https://ace.hawkeye.services-edge.paloaltonetworks.com/",
                        "https://aefd.nelreports.net/",
                        "https://agent-directory-sync.au.apps.paloaltonetworks.com/",
                        "https://api-xdr20japan.xdr.us.paloaltonetworks.com/",
                        "https://api-xsiam-sandbox-japac.xdr.au.paloaltonetworks.com/",
                        "https://api.demisto.com/",
                        "https://api.diagnostics.office.com/",
                        "https://api.github.com/",
                        "https://api.msn.com/",
                        "https://api.snapcraft.io/",
                        "https://api4.prismacloud.io/",
                        "https://app-registry-service.apps.paloaltonetworks.com/",
                        "https://apprep.smartscreen.microsoft.com/",
                        "https://apps.splunk.com/",
                        "https://arc.msn.com/",
                        "https://arm-ring.msedge.net/",
                        "https://assets.msn.cn/",
                        "https://assets.msn.com/",
                        "https://atm-fp-direct.office.com/",
                        "https://augloop.office.com/",
                        "https://augmentation.osi.office.net/",
                        "https://aus5.mozilla.org/",
                        "https://auth.docker.io/",
                        "https://autodiscover-s.outlook.com/",
                        "https://autofocus.paloaltonetworks.com/",
                        "https://avatars.githubusercontent.com/",
                        "https://ax-ring.msedge.net/",
                        "https://b1t-sindc1.zemanta.com/",
                        "https://binaries.templates.cdn.office.net/",
                        "https://br-prd1.au1.se1.cdl.paloaltonetworks.com/",
                        "https://br-prd1.us.cdl.paloaltonetworks.com/",
                        "https://browser.events.data.msn.com/",
                        "https://browser.pipe.aria.microsoft.com/",
                        "https://c.bing.com/",
                        "https://c.msn.com/",
                        "https://canonical-bos01.cdn.snapcraftcontent.com/",
                        "https://canonical-lgw01.cdn.snapcraftcontent.com/",
                        "https://cc-xdr20japan.traps.paloaltonetworks.com/",
                        "https://cc-xsiam-sandbox-japac.traps.paloaltonetworks.com/",
                        "https://cdn.fwupd.org/",
                        "https://cdn.splunkbase.splunk.com/",
                        "https://certificatetrusted.paloaltonetworks.com/",
                        "https://ch-xdr20japan.traps.paloaltonetworks.com/",
                        "https://ch-xsiam-sandbox-japac.traps.paloaltonetworks.com/",
                        "https://changelogs.ubuntu.com/",
                        "https://checkappexec.microsoft.com/",
                        "https://classify-client.services.mozilla.com/",
                        "https://client.wns.windows.com/",
                        "https://clients.config.office.net/",
                        "https://cm.mgid.com/",
                        "https://code.yengo.com/",
                        "https://collector.github.com/",
                        "https://config.edge.skype.com/",
                        "https://config.officeapps.live.com/",
                        "https://config.teams.microsoft.com/",
                        "https://content-signature-2.cdn.mozilla.net/",
                        "https://contile.services.mozilla.com/",
                        "https://contracts.canonical.com/",
                        "https://cp801.prod.do.dsp.mp.microsoft.com/",
                        "https://crl.paloaltonetworks.com/",
                        "https://cs.paloaltonetworks.com:3978/",
                        "https://cxcs.microsoft.net/",
                        "https://da.xboxservices.com/",
                        "https://data-edge.smartscreen.microsoft.com/",
                        "https://data.pendo.io/",
                        "https://dc-xdr20japan.traps.paloaltonetworks.com/",
                        "https://dc-xsiam-sandbox-japac.traps.paloaltonetworks.com/",
                        "https://default.exp-tas.com/",
                        "https://disc801.prod.do.dsp.mp.microsoft.com/",
                        "https://displaycatalog.mp.microsoft.com/",
                        "https://dl.fedoraproject.org/",
                        "https://dlassets-ssl.xboxlive.com/",
                        "https://dns.service.paloaltonetworks.com/",
                        "https://download-installer.cdn.mozilla.net/",
                        "https://download.demisto.com/",
                        "https://download.docker.com/",
                        "https://download.mozilla.org/",
                        "https://e1345286.api.splkmobile.com/",
                        "https://eb2.3lift.com/",
                        "https://ecs.nel.measure.office.net/",
                        "https://ecs.office.com/",
                        "https://edge-consumer-static.azureedge.net/",
                        "https://edge-mobile-static.azureedge.net/",
                        "https://edge.microsoft.com/",
                        "https://edgeassetservice.azureedge.net/",
                        "https://edgestatic.azureedge.net/",
                        "https://edl-xdr20japan.xdr.us.paloaltonetworks.com/",
                        "https://encrypted-tbn0.gstatic.com/",
                        "https://encrypted-tbn2.gstatic.com/",
                        "https://enforcer.iot.services-edge.paloaltonetworks.com/",
                        "https://esm.ubuntu.com/",
                        "https://ev2-ring.msedge.net/",
                        "https://example.com/",
                        "https://fa0000000{''.join(random.choices(string.digits, k=2))}.resources.office.net/",
                        "https://fd.api.iris.microsoft.com/",
                        "https://fe2.update.microsoft.com/",
                        "https://fe2cr.update.microsoft.com/",
                        "https://fe3.delivery.mp.microsoft.com/",
                        "https://fe3cr.delivery.mp.microsoft.com/",
                        "https://ffd220d81a7b47628c3d64f46213b30d.fp.measure.office.com/",
                        "https://firefox-settings-attachments.cdn.mozilla.net/",
                        "https://firefox.settings.services.mozilla.com/",
                        "https://fonts.gstatic.com/",
                        "https://fp-afd.azureedge.net/",
                        "https://fp-afd.azureedge.us/",
                        "https://fp-vs-nocache.azureedge.net/",
                        "https://fp-vs.azureedge.net/",
                        "https://fp.msedge.net/",
                        "https://fs.microsoft.com/",
                        "https://functional.events.data.microsoft.com/",
                        "https://g.live.com/",
                        "https://g.msn.com/",
                        "https://geo.prod.do.dsp.mp.microsoft.com/",
                        "https://geover.prod.do.dsp.mp.microsoft.com/",
                        "https://github.com/",
                        "https://github.githubassets.com/",
                        "https://go.microsoft.com/",
                        "https://gravatar.com/",
                        "https://hbx.media.net/",
                        "https://hub.docker.com/",
                        "https://imageaws.popin.cc/",
                        "https://img-s-msn-com.akamaized.net/",
                        "https://incoming.telemetry.mozilla.org/",
                        "https://io.dns.service.paloaltonetworks.com/",
                        "https://ipinfo.io/",
                        "https://iteactive-tya.msedge.net/",
                        "https://jpn01.safelinks.protection.outlook.com/",
                        "https://kv801.prod.do.dsp.mp.microsoft.com/",
                        "https://l-ring.msedge.net/",
                        "https://licensing.mp.microsoft.com/",
                        "https://livepatch.canonical.com/",
                        "https://location.services.mozilla.com/",
                        "https://login.live.com/",
                        "https://login.microsoftonline.com/",
                        "https://lrc-au.paloaltonetworks.com/",
                        "https://maps.windows.com/",
                        "https://marketplace.xsoar.paloaltonetworks.com/",
                        "https://messaging.lifecycle.office.com/",
                        "https://metadata.templates.cdn.office.net/",
                        "https://mirrors.fedoraproject.org/",
                        "https://ml-static.service.paloaltonetworks.com/",
                        "https://ml.service.paloaltonetworks.com/",
                        "https://mobile.events.data.microsoft.com/",
                        "https://motd.ubuntu.com/",
                        "https://mrodevicemgr.officeapps.live.com/",
                        "https://msedge.api.cdp.microsoft.com/",
                        "https://nav-edge.smartscreen.microsoft.com/",
                        "https://nav.smartscreen.microsoft.com/",
                        "https://nexusrules.officeapps.live.com/",
                        "https://nleditor.osi.office.net/",
                        "https://normandy.cdn.mozilla.net/",
                        "https://notepad-plus-plus.org/",
                        "https://ntp.msn.com/",
                        "https://objects.githubusercontent.com/",
                        "https://odc.officeapps.live.com/",
                        "https://odinvzc.azureedge.net/",
                        "https://officeclient.microsoft.com/",
                        "https://ols.officeapps.live.com/",
                        "https://omex.cdn.office.net/",
                        "https://oneclient.sfx.ms/",
                        "https://oproxy.demisto.ninja/",
                        "https://otx.alienvault.com/",
                        "https://outlook.office.com/",
                        "https://outlook.office365.com/",
                        "https://outlookmobile-office365-tas.msedge.net/",
                        "https://ow1.res.office365.com/",
                        "https://p-ring.msedge.net/",
                        "https://panos.wildfire.paloaltonetworks.com/",
                        "https://ping-edge.smartscreen.microsoft.com/",
                        "https://pr-bh.ybp.yahoo.com/",
                        "https://proditpdownloads.paloaltonetworks.com/",
                        "https://production.cloudflare.docker.com/",
                        "https://pubmirror1.math.uh.edu/",
                        "https://push.services.mozilla.com/",
                        "https://quickdraw.splunk.com/",
                        "https://r.bing.com/",
                        "https://r.msftstatic.com/",
                        "https://r4---sn-uxjoxu-ogue.gvt1.com/",
                        "https://r4.res.office365.com/",
                        "https://raw.githubusercontent.com/",
                        "https://redirector.gvt1.com/",
                        "https://registry-1.docker.io/",
                        "https://repo.jing.rocks/",
                        "https://roaming.officeapps.live.com/",
                        "https://rum8.perf.linkedin.com/",
                        "https://s-ring.msedge.net/",
                        "https://s0000.urlcloud.paloaltonetworks.com/",
                        "https://safelinks.protection.outlook.com/",
                        "https://sb.scorecardresearch.com/",
                        "https://segments-s.msedge.net/",
                        "https://self.events.data.microsoft.com/",
                        "https://serverlist.urlcloud.paloaltonetworks.com/",
                        "https://serverlist2.urlcloud.paloaltonetworks.com/",
                        "https://serverlist3.urlcloud.paloaltonetworks.com/",
                        "https://services.addons.mozilla.org/",
                        "https://services.nvd.nist.gov/",
                        "https://settings-win.data.microsoft.com/",
                        "https://shavar.services.mozilla.com/",
                        "https://shftr.adnxs.net/",
                        "https://shredder.osi.office.net/",
                        "https://sin3-ib.adnxs.com/",
                        "https://slack.com/",
                        "https://sls.update.microsoft.com/",
                        "https://slscr.update.microsoft.com/",
                        "https://spo-ring.msedge.net/",
                        "https://spocs.getpocket.com/",
                        "https://spoppe-b.azureedge.net/",
                        "https://srtb.msn.com/",
                        "https://ssl.gstatic.com/",
                        "https://staging.to-do.microsoft.com/",
                        "https://staging.to-do.officeppe.com/",
                        "https://static.dns.service.paloaltonetworks.com/",
                        "https://static.edge.microsoftapp.net/",
                        "https://statics.teams.cdn.live.net/",
                        "https://storecatalogrevocation.storequality.microsoft.com/",
                        "https://storeedgefd.dsx.mp.microsoft.com/",
                        "https://substrate.office.com/",
                        "https://sync.outbrain.com/",
                        "https://t-ring-s.msedge.net/",
                        "https://t-ring-s2.msedge.net/",
                        "https://t-ring.msedge.net/",
                        "https://teams-ring.msedge.net/",
                        "https://teams.events.data.microsoft.com/",
                        "https://teams.live.com/",
                        "https://telecommand.telemetry.microsoft.com/",
                        "https://telem-edge.smartscreen.microsoft.com/",
                        "https://telemetry-splkmobile.dataeng.splunk.com/",
                        "https://th.bing.com/",
                        "https://tiles-cdn.prod.ads.prod.webservices.mozgcp.net/",
                        "https://to-do.microsoft.com/",
                        "https://to-do.office.com/",
                        "https://trace.popin.cc/",
                        "https://tracking-protection.cdn.mozilla.net/",
                        "https://trc.taboola.com/",
                        "https://tring.clo.footprintdns.com/",
                        "https://tse1.mm.bing.net/",
                        "https://tsfe.trafficshaping.dsp.mp.microsoft.com/",
                        "https://uci.cdn.office.net/",
                        "https://umwatson.events.data.microsoft.com/",
                        "https://unit42intel.xsoar.paloaltonetworks.com/",
                        "https://updates.paloaltonetworks.com/",
                        "https://upload.fp.measure.office.com/",
                        "https://urlcat.hawkeye.services-edge.paloaltonetworks.com/",
                        "https://ussus3westprod.blob.core.windows.net/",
                        "https://v10.events.data.microsoft.com/",
                        "https://v20.events.data.microsoft.com/",
                        "https://wa104381125.resources.office.net/",
                        "https://wac-ring.msedge.net/",
                        "https://waconafd.officeapps.live.com/",
                        "https://waconatm.officeapps.live.com/",
                        "https://watson.events.data.microsoft.com/",
                        "https://watson.telemetry.microsoft.com/",
                        "https://wdcp.microsoft.com/",
                        "https://wdcpalt.microsoft.com/",
                        "https://wildfire.paloaltonetworks.com/",
                        "https://windows.msn.com/",
                        "https://wiresharkfoundation.report.report-uri.com/",
                        "https://wns2-pn1p.wns.windows.com/",
                        "https://wss-primary.slack.com/",
                        "https://www.bing.com/",
                        "https://www.gstatic.com/",
                        "https://www.microsoft.com/",
                        "https://www.mozilla.org/",
                        "https://www.msn.com/",
                        "https://www.telecommandsvc.microsoft.com/",
                        "https://www.virustotal.com/",
                        "https://www.wireshark.org/",
                        "https://www.xboxab.com/",
                        "https://www2.bing.com/",
                        "https://xpaywalletcdn.azureedge.net/",
                        "https://xsoar-marketplace-review.paloaltonetworks.com/",
                        "https://{''.join(random.choices(string.hexdigits, k=32))}.fp.measure.office.com/"
                    ]
                },
                ".weights": 100
            },
            {
                ".variables": {
                    "words": ["year","time","people","way","day","man","thing","woman","life","child","world","school","state","family","student","group","country","hand","part","place","case","week","company","system","program","question","work","number","night","point","home","water","room","mother","area","money","story","fact","month","lot","right","study","book","eye","job","word","business","issue","side","kind","head","house","service","friend","father","power","hour","game","line","end","member","law","car","city","community","name","president","team","minute","idea","kid","body","information","back","parent","face","level","office","door","health","person","art","war","history","party","result","change","morning","reason","research","girl","guy","moment","air","teacher","force","education"]
                },
                "operation": "internal.outbound",
                "type": "network",
                "src": "172.16.77.0/24",
                "src_user": null,
                "src_host": null,
                "src_domain": null,
                "dst": "public",
                "dst_port": 443,
                "ip_protocol": "tcp",
                "app_protocol": "https",
                "fw_action": "allow",
                "http": {
                    "default": {
                        "resp_status": 200,
                        "resp_bytes": "{random.randint(2048, 1024 * 1024)}"
                    },
                    "dst": [
                        "https://www.{''.join(random.choices(words, k=2))}.{random.choice(['com','net','org'])}",
                        "https://{''.join(random.choices(words, k=2))}.{random.choice(['com','net','org'])}"
                    ]
                },
                ".weights": 5
            },
            {
                ".variables": {
                    "words": ["year","time","people","way","day","man","thing","woman","life","child","world","school","state","family","student","group","country","hand","part","place","case","week","company","system","program","question","work","number","night","point","home","water","room","mother","area","money","story","fact","month","lot","right","study","book","eye","job","word","business","issue","side","kind","head","house","service","friend","father","power","hour","game","line","end","member","law","car","city","community","name","president","team","minute","idea","kid","body","information","back","parent","face","level","office","door","health","person","art","war","history","party","result","change","morning","reason","research","girl","guy","moment","air","teacher","force","education"]
                },
                "operation": "internal.outbound",
                "type": "network",
                "src": "172.16.77.0/24",
                "src_user": null,
                "src_host": null,
                "src_domain": null,
                "dst": "public",
                "dst_port": 443,
                "ip_protocol": "tcp",
                "app_protocol": "https",
                "fw_action": "allow",
                "http": {
                    "default": {
                        "resp_status": 500,
                        "resp_bytes": "{random.randint(2048, 10000)}"
                    },
                    "dst": [
                        "https://www.{'-'.join(random.choices(words, k=2))}.{random.choice(['com','net','org'])}",
                        "https://{'-'.join(random.choices(words, k=2))}.{random.choice(['com','net','org'])}"
                    ]
                },
                ".weights": 5
            },
            {
                "#": "Cooporate Potal",
                "operation": "internal.outbound",
                "type": "network",
                "src": "172.16.77.0/24",
                "src_user": null,
                "src_host": null,
                "src_domain": null,
                "dst": "172.16.78.10",
                "dst_port": 443,
                "ip_protocol": "tcp",
                "app_protocol": "https",
                "fw_action": "allow",
                "http": {
                    "default": {
                        "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36",
                        "req_method": "GET",
                        "req_version": "HTTP/1.1",
                        "resp_bytes": "{random.randint(2048, 1024 * 1024)}",
                        "resp_content_type": "text/html; charset=UTF-8"
                    },
                    "dst": [
                        "http://portal.corp.panw.lan/",
                        "http://portal.corp.panw.lan/index.html",
                        "http://portal.corp.panw.lan/product",
                        "http://portal.corp.panw.lan/calendar",
                        "http://portal.corp.panw.lan/contact",
                        {
                            "url": "https://portal.corp.panw.lan/item/product/{''.join(random.choices(string.digits, k=4))}.html",
                            "resp_status": "{random.choices([200, 304, 404], weights=[10, 50, 2])[0]}",
                            ".weights": 100
                        }
                    ]
                },
                ".weights": 10
            },
            {
                "#": "endpoints -> endpoints",
                "operation": "internal.outbound",
                "type": "network",
                "src": "172.16.77.0/24",
                "src_user": null,
                "src_host": null,
                "src_domain": null,
                "dst": "172.16.77.0/24",
                "dst_port": "137, 138",
                "ip_protocol": "udp",
                "fw_action": "allow",
                ".weights": 50
            },
            {
                "#": "endpoints -> AD",
                "operation": "internal.outbound",
                "type": "network",
                "src": "172.16.77.0/24",
                "src_user": null,
                "src_host": null,
                "src_domain": null,
                "dst": "172.16.77.20",
                "dst_port": "137, 138",
                "ip_protocol": "udp",
                "fw_action": "allow",
                ".weights": 250
            },
            {
                "#": "endpoints -> AD",
                "operation": "internal.outbound",
                "type": "network",
                "src": "172.16.77.0/24",
                "src_user": null,
                "src_host": null,
                "src_domain": null,
                "dst": "172.16.77.20",
                "dst_port": "135, 389, 445",
                "ip_protocol": "tcp",
                "fw_action": "allow",
                ".weights": 250
            }
        ],
        "jobs": [
            {
                "#": "Windows Executable Download - Windows Update",
                ".interval": "{random.randint(3600, 7200)}",
                "sources": {
                    ".variables": {
                        "src_ip": "172.16.77.{random.randint(10, 14)}",
                        "src_port": "{random.randint(10000, 65534)}",
                        "dst_ip": "{random.choice(['151.139.176.44', '151.139.176.36'])}",
                        "dst_path": "c/msdownload/update/software/defu/{datetime.datetime.now().year}/{datetime.datetime.now().month}/am_delta_patch_1.{random.randint(100,999)}.{random.randint(100,999)}.0_{''.join(random.choices(string.hexdigits, k=40))}.exe?cacheHostOrigin=au.download.windowsupdate.com"
                    },
                    ".next": {
                        "mode": "sequential",
                        "sources": {
                            "operation": "internal.outbound",
                            "type": "network",
                            "src": "{src_ip}",
                            "src_port": "{src_port}",
                            "src_user": null,
                            "src_host": null,
                            "src_domain": null,
                            "dst": "{dst_ip}",
                            "dst_port": 80,
                            "ip_protocol": "tcp",
                            "app_protocol": "http",
                            "fw_action": "allow",
                            "http": {
                                "default": {
                                    "user_agent": "Windows-Update-Agent/923.614.111.0 Client-Protocol/2.71",
                                    "req_method": "GET",
                                    "req_version": "HTTP/1.1",
                                    "resp_status": 200,
                                    "resp_bytes": "{random.randint(1024 * 1024, 10 * 1024 * 1024)}"
                                },
                                "dst": [
                                    "http://au.download.windowsupdate.com/{dst_path}"
                                ]
                            },
                            ".wait": 10,
                            ".next": {
                                "mode": "sequential",
                                "sources": {
                                    "operation": "log",
                                    "type": "ngfw-threat",
                                    "params": {
                                        "subtype": "wildfire",
                                        "source_ip": "{src_ip}",
                                        "source_user": null,
                                        "source_port": "{src_port}",
                                        "dest_ip": "{dst_ip}",
                                        "dest_port": 80,
                                        "protocol": "tcp",
                                        "app": "web-browsing",
                                        "app_category": "general-internet",
                                        "app_sub_category": "internet-utility",
                                        "threat_name": "Windows Executable (EXE)",
                                        "threat_category": "unknown",
                                        "direction": "server to client",
                                        "misc": "{dst_ip}/{dst_path}"
                                    }
                                }
                            }
                        }
                    }
                }
            },
            {
                "#": "AD Authentication - Success",
                ".interval": "{random.randint(0, 600)}",
                "sources": {
                    ".variables": {
                        "x": "{random.randint(1, 199)}"
                    },
                    "operation": "log",
                    "type": "windows-event-ad",
                    "src_ip": "172.16.77.{x}",
                    "dst_host": "slp-ad.corp.panw.lan",
                    "event_result": "success",
                    "event_id": 4768
                }
            },
            {
                "#": "DHCP address renewal",
                ".interval": "{random.randint(0, 800)}",
                "sources": [
                    {
                        ".variables": {
                            "x": {
                                "type": "eval",
                                "value": "random.randint(1, 199)"
                            }
                        },
                        ".next": {
                            "mode": "sequential",
                            "sources": {
                                "operation": "internal.log",
                                "type": "dhcp",
                                "src_ip": "172.16.77.{x}",
                                "src_user": null,
                                "src_mac": "00:0c:29:dd:22:{x:02x}",
                                "action": "update-request",
                                ".next": {
                                    "mode": "sequential",
                                    "sources": {
                                        "operation": "internal.log",
                                        "type": "dhcp",
                                        "src_ip": "172.16.77.{x}",
                                        "src_mac": "00:0c:29:dd:22:{x:02x}",
                                        "action": "renew"
                                    }
                                }
                            }
                        },
                        ".wait": "{random.randint(0, 10)}",
                        ".repeat": 100
                    }
                ]
            },
            {
                "#": "Remote Access - Cisco AnyConnect VPN",
                ".interval": "{random.randint(600, 3 * 3600)}",
                "sources": {
                    ".variables": {
                        "user_params": {
                            "type": "eval",
                            "value": "random.choices([{'n': n, 'user': uid} for n, uid in enumerate(__users)], k=30)"
                        }
                    },
                    "operation": "log",
                    "type": "custom",
                    "cef_version": "0",
                    "cef_vendor": "Cisco",
                    "cef_product": "ASA",
                    "log_format": "raw",
                    "log_params": "%ASA-6-113039: Group <grp-policy> User <{user}> IP <{hash(str(n)) & 0xf8 | 0x3}.22.33.{n}> AnyConnect parent session started.",

                    ".repeat": {
                        "iter_vars": "user_params"
                    },
                    ".wait": "{random.randint(30, 180)}"
                }
            }
        ]
    }
    '''

        SCENARIO_IRREGULAR = r'''
    {
        ".variables": {
        },
        "sources": [
            {
                "#": "Random-Looking Domain Names",
                "operation": "internal.outbound",
                "type": "network",
                "src": "172.16.77.0/24",
                "src_user": null,
                "src_host": null,
                "src_domain": null,
                "dst": "public",
                "dst_port": 443,
                "ip_protocol": "tcp",
                "app_protocol": "https",
                "fw_action": "allow",
                "http": {
                    "default": {
                        "resp_status": 200,
                        "resp_bytes": "{random.randint(2048, 1024 * 1024)}"
                    },
                    "dst": [
                        "https://www.{''.join(random.choices(string.ascii_lowercase + '_', k=8))}.{random.choice(['com','net','org'])}",
                        "https://{''.join(random.choices(string.ascii_lowercase + '_', k=16))}.{random.choice(['com','net','org'])}"
                    ]
                },
                ".weights": 0.01
            },
            {
                "operation": "internal.outbound",
                "type": "network",
                "src": "172.16.77.0/24",
                "src_user": null,
                "src_host": null,
                "src_domain": null,
                "dst": "public",
                "dst_port": "25, 110, 143, 3389, 8080",
                "ip_protocol": "tcp",
                "fw_action": "drop"
            }
        ],
        "jobs": [
            {
                "#": "DGA - Random Domain Name Queries",
                ".interval": "{random.randint(7200, 14400)}",
                "sources": {
                    ".variables": {
                        "domain": "{''.join(random.choices(string.ascii_lowercase, k=32))}.com",
                        "host": "{''.join(random.choices(string.ascii_lowercase, k=4))}",
                        "src_ip": "172.16.77.{random.randint(10, 14)}",
                        "src_port": "{random.randint(10000, 65534)}"
                    },
                    ".next": {
                        "mode": "sequential",
                        "sources": {
                            "operation": "internal.outbound",
                            "type": "network",
                            "src": "{src_ip}",
                            "src_port": "{src_port}",
                            "src_user": null,
                            "src_host": null,
                            "src_domain": null,
                            "dst": "172.16.78.2",
                            "dst_port": 53,
                            "ip_protocol": "udp",
                            "app_protocol": "dns",
                            "fw_action": "allow",
                            "dns": {
                                "queries": {
                                    "name": "{host}.{domain}",
                                    "type": "A"
                                }
                            },
                            ".wait": 10,
                            ".next": {
                                "mode": "sequential",
                                "sources": {
                                    "operation": "log",
                                    "type": "ngfw-threat",
                                    "params": {
                                        "subtype": "spyware",
                                        "source_ip": "{src_ip}",
                                        "source_user": null,
                                        "source_port": "{src_port}",
                                        "dest_ip": "172.16.78.2",
                                        "dest_port": 53,
                                        "protocol": "udp",
                                        "app": "dns-base",
                                        "app_category": "networking",
                                        "app_sub_category": "infrastructure",
                                        "threat_name": "DGA:{host}.{domain}",
                                        "threat_category": "dns-c2",
                                        "direction": "client to server"
                                    }
                                }
                            }
                        }
                    }
                }
            },
            {
                "#": "Uncommon SSH session",
                ".interval": "{random.randint(7200, 14400)}",
                "sources": {
                    ".variables": {
                        "x": "{random.randint(1, 199)}"
                    },
                    "operation": "internal.outbound",
                    "type": "network",
                    "src": "172.16.77.{x}",
                    "src_user": null,
                    "src_host": null,
                    "src_domain": null,
                    "dst": "public",
                    "dst_port": "22",
                    "ip_protocol": "tcp",
                    "fw_action": "drop"
                }
            },
            {
                "#": "DNS tunneling",
                ".interval": "{random.randint(0, 7200)}",
                "sources": {
                    ".variables": {
                        "domain": "{random.choice(['go0gie.com','pawevi.com','anyconnect.stream','bigip.stream','fortiweb.download','kaspersky.science','microtik.stream','owa365.bid','symanteclive.download','windowsdefender.win'])}"
                    },
                    ".next": {
                        "mode": "sequential",
                        "sources": {
                            "operation": "internal.outbound",
                            "type": "network",
                            "src": "172.16.77.{datetime.datetime.now().day}",
                            "src_user": null,
                            "src_host": null,
                            "src_domain": null,
                            "dst": "172.16.78.2",
                            "dst_port": 53,
                            "ip_protocol": "udp",
                            "app_protocol": "dns",
                            "fw_action": "allow",
                            "dns": {
                                "queries": [
                                    {
                                        "name": "{''.join(random.choices(string.ascii_lowercase, k=32))}.{domain}",
                                        "type": "A"
                                    }
                                ]
                            },
                            ".repeat": 10000
                        }
                    }
                }
            },
            {
                "#": "Port Scan + SMB: User Password Brute Force Attempt",
                ".interval": "{random.randint(0, 7200)}",
                "sources": {
                    ".variables": {
                        "src": "172.16.77.{random.randint(10, 14)}"
                    },
                    ".next": {
                        "mode": "sequential",
                        "sources": [
                            {
                                "operation": "internal.outbound",
                                "type": "network",
                                "src": "{src}",
                                "src_user": null,
                                "src_host": null,
                                "src_domain": null,
                                "dst": "172.16.78.{random.randint(1, 199)}",
                                "dst_port": "{random.randint(1, 65534)}",
                                "ip_protocol": "tcp",
                                "app_protocol": "incomplete",
                                "fw_action": "allow",
                                ".repeat": 600000
                            },
                            {
                                ".variables": {
                                    "source_port": "{random.randint(10000, 65534)}",
                                    "dst": "172.16.78.{random.randint(1, 199)}"
                                },
                                ".next": {
                                    "mode": "sequential",
                                    "sources": [
                                        {
                                            "operation": "internal.outbound",
                                            "type": "network",
                                            "src": "{src}",
                                            "src_user": null,
                                            "src_host": null,
                                            "src_domain": null,
                                            "dst": "{dst}",
                                            "dst_port": "445",
                                            "ip_protocol": "tcp",
                                            "app_protocol": "incomplete",
                                            "fw_action": "allow"
                                        },
                                        {
                                            "operation": "log",
                                            "type": "ngfw-threat",
                                            "params": {
                                                "subtype": "vulnerability",
                                                "source_ip": "{src}",
                                                "source_user": null,
                                                "source_port": "{source_port}",
                                                "dest_ip": "{dst}",
                                                "dest_port": "445",
                                                "protocol": "tcp",
                                                "app": "ms-ds-smbv3",
                                                "app_category": "business-systems",
                                                "app_sub_category": "storage-backup",
                                                "threat_name": "SMB: User Password Brute Force Attempt(40004)",
                                                "threat_category": "brute-force",
                                                "direction": "client-to-server",
                                                ".wait": 10
                                            }
                                        },
                                        {
                                            "operation": "log",
                                            "type": "ngfw-threat",
                                            "params": {
                                                "subtype": "vulnerability",
                                                "source_ip": "{src}",
                                                "source_user": null,
                                                "source_port": "{source_port}",
                                                "dest_ip": "{dst}",
                                                "dest_port": "445",
                                                "protocol": "tcp",
                                                "app": "ms-ds-smbv3",
                                                "app_category": "business-systems",
                                                "app_sub_category": "storage-backup",
                                                "threat_name": "Windows SMB Login Attempt",
                                                "threat_category": "brute-force",
                                                "direction": "client-to-server"
                                            }
                                        }
                                    ]
                                },
                                ".repeat": {
                                    "count": "{random.randint(10, 20)}"
                                }
                            }
                        ]
                    }
                }
            },
            {
                "#": "Malicious PowerShell Script",
                ".interval": "{random.randint(0, 7200)}",
                "sources": {
                    ".variables": {
                        "src": "172.16.77.{random.randint(1, 199)}",
                        "dst": "185.199.110.133"
                    },
                    ".next": {
                        "mode": "sequential",
                        "sources": [
                            {
                                "operation": "internal.outbound",
                                "type": "network",
                                "src": "{src}",
                                "src_user": null,
                                "src_host": null,
                                "src_domain": null,
                                "dst": "{dst}",
                                "dst_port": "443",
                                "ip_protocol": "tcp",
                                "app_protocol": "github-downloading",
                                "fw_action": "allow"
                            },
                            {
                                "operation": "log",
                                "type": "ngfw-threat",
                                "params": {
                                    "subtype": "ml-virus",
                                    "source_ip": "{src}",
                                    "source_user": null,
                                    "source_port": "{random.randint(10000, 65534)}",
                                    "dest_ip": "{dst}",
                                    "dest_port": "443",
                                    "protocol": "tcp",
                                    "app": "github-downloading",
                                    "app_category": "saas",
                                    "app_sub_category": "management",
                                    "threat_name": "Malicious PowerShell Script",
                                    "threat_category": "powershell1",
                                    "direction": "server to client",
                                    "misc": "xma.g00g1e.net/xp101t.ps1"
                                }
                            }
                        ]
                    }
                }
            },
            {
                "#": "A Successful VPN connection from TOR - Cisco AnyConnect VPN (May require syslog ingestion)",
                ".interval": "{random.randint(43200, 86400)}",
                "sources": {
                    ".variables": {
                        "user": "{random.choice(list(__users))}",
                        "tor_ip": "{random.choice(['171.25.193.25','80.67.167.81','192.42.116.187','198.98.51.189','89.58.26.216','109.70.100.4','149.56.22.133'])}"
                    },
                    "operation": "log",
                    "type": "custom",
                    "cef_version": "0",
                    "cef_vendor": "Cisco",
                    "cef_product": "ASA",
                    "log_format": "raw",
                    "log_params": "%ASA-6-113039: Group <grp-policy> User <{user}> IP <{tor_ip}> AnyConnect parent session started."
                }
            }
        ]
    }
    '''

        @staticmethod
        def __build_ip_entries(
        ) -> dict[str, Any]:
            users = [
                'lsears', 'fmayo', 'mdunlap', 'mhayden', 'twilder',
                'cmckay', 'mcoffey', 'omccarty', 'jewing', 'jcooley',
                'tvaughan', 'cbonner', 'acotton', 'jholder', 'rstark',
                'bferrell', 'lcantrell', 'tfulton', 'llynn', 'dlott',
                'wcalderon', 'drosa', 'jpollard', 'fhooper', 'lburch',
                'amullen', 'tfry', 'wriddle', 'glevy', 'ddavid',
                'gduke', 'jodonnell', 'dguy', 'pmichael', 'dbritt',
                'dfrederick', 'ldaugherty', 'zberger', 'cdillard', 'halston',
                'mjarvis', 'vfrye', 'rriggs', 'cchaney', 'godom',
                'hduffy', 'sfitzpatrick', 'rvalenzuela', 'smerrill', 'rmayer',
                'lalford', 'bmcpherson', 'racevedo', 'cdonovan', 'tbarrera',
                'galbert', 'gcote', 'mreilly', 'rcompton', 'rraymond',
                'bmooney', 'amcgowan', 'ncraft', 'rcleveland', 'lclemons',
                'ewynn', 'mnielsen', 'rbaird', 'bstanton', 'csnider',
                'crosales', 'dbright', 'fwitt', 'astuart', 'ehays',
                'bholden', 'grutledge', 'rkinney', 'mclements', 'rcastaneda',
                'aslater', 'hhahn', 'jemerson', 'aconrad', 'kburks',
                'cdelaney', 'cpate', 'elancaster', 'dsweet', 'jjustice',
                'ntyson', 'jsharpe', 'cwhitfield', 'jtalley', 'fmacias',
            ]
            return {
                f'172.16.77.{i}': assign_params(
                    host=f'SLP-{i:04}',
                    domain='corp.panw.lan',
                    user=user,
                ) for i, user in itertools.zip_longest(range(1, 201), users)
            }

        @staticmethod
        def build_default(
            settings: Settings,
        ) -> Self:
            """ Create the default scenario

            :param settings: The instance settings.
            :return: The default scenario.
            """
            scenario = DefaultScenario()
            if 'normal' in settings.default_scenario_list:
                scenario.set_normal_scenario()

            if 'irregular' in settings.default_scenario_list:
                scenario.set_irregular_scenario()

            scenario.set_internal_tap(
                settings.default_scenario_internal_tap_products
            )
            scenario.set_external_tap(
                settings.default_scenario_external_tap_products
            )
            if settings.default_scenario_internal_proxy_squid_log_formats:
                scenario.set_internal_proxy_squid(
                    settings.default_scenario_internal_proxy_squid_log_formats
                )
            if settings.default_scenario_internal_web_apache_log_formats:
                scenario.set_internal_web_apache(
                    settings.default_scenario_internal_web_apache_log_formats
                )
            scenario.set_internal_dns_bind()
            scenario.set_internal_dhcp_windows()

            if 'zscaler-nssweb' in settings.default_scenario_external_proxy_products:
                scenario.set_external_proxy_nssweb()

            return scenario

        def __init__(
            self,
        ) -> None:
            """ Initialize the scenario.
            """
            self.__internal_tap: list[dict[str, Any]] | None = None
            self.__internal_proxy_squid: dict[str, Any] | None = None
            self.__internal_web_apache: dict[str, Any] | None = None
            self.__internal_dns_bind: dict[str, Any] | None = None
            self.__internal_dhcp_windows: dict[str, Any] | None = None
            self.__external_tap: list[dict[str, Any]] | None = None
            self.__external_proxy_nssweb: dict[str, Any] | None = None
            self.__normal_scenario: dict[str, Any] | None = None
            self.__irregular_scenario: dict[str, Any] | None = None

        def set_normal_scenario(
            self,
        ) -> None:
            """ Set the default normal scenario
            """
            self.__normal_scenario = json.loads(self.SCENARIO_NORMAL)

        def set_irregular_scenario(
            self,
        ) -> None:
            """ Set the default irregular scenario
            """
            self.__irregular_scenario = json.loads(self.SCENARIO_IRREGULAR)

        def set_internal_tap(
            self,
            names: list[str],
        ) -> None:
            """ Set the internal TAP services.

            :param names: List of product names.
            """
            self.__internal_tap = []
            for name in names:
                if service := {
                    'ngfw': {
                        'product': 'ngfw',
                        'ip': '172.16.77.251',
                        'fqdn': 'ngdw.corp.panw.lan'
                    },
                    'checkpoint-fw': {
                        'product': 'checkpoint-fw',
                        'ip': '172.16.77.252',
                        'fqdn': 'checkpoint.corp.panw.lan'
                    },
                    'fortigate': {
                        'product': 'fortigate',
                        'ip': '172.16.77.253',
                        'fqdn': 'fortigate.corp.panw.lan'
                    }
                }.get(name):
                    self.__internal_tap.append(service)
                else:
                    raise DemistoException(f'Invalid tap product - {name}')

        def set_internal_proxy_squid(
            self,
            log_formats: list[str],
        ) -> None:
            """ Set the internal squid proxy service.

            :param log_formats: List of log formats.
            """
            supported_log_formats = {'squid', 'common', 'combined'}
            if not supported_log_formats.issuperset(log_formats):
                invalid_log_formats = ', '.join(set(log_formats) - supported_log_formats)
                raise DemistoException(f'Invalid squid log format - {invalid_log_formats}')

            self.__internal_proxy_squid = {
                'product': 'squid',
                'ip': '172.16.77.250',
                'port': 8080,
                'fqdn': 'squid.corp.panw.lan',
                'protocol': ['http', 'https'],
                'proxy': {
                    'rule': {
                        'src': ['172.16.77.0/27', '172.16.77.128/27']
                    },
                    'exception': {
                        'dst': '172.16.0.0/16'
                    }
                },
                'squid': {
                    'log_format': log_formats
                }
            }

        def set_internal_web_apache(
            self,
            log_formats: list[str],
        ) -> None:
            """ Set the internal web service.

            :param log_formats: List of log formats.
            """
            supported_log_formats = {'common', 'combined'}
            if not supported_log_formats.issuperset(log_formats):
                invalid_log_formats = ', '.join(set(log_formats) - supported_log_formats)
                raise DemistoException(f'Invalid apache log format - {invalid_log_formats}')

            self.__internal_web_apache = {
                'product': 'apache-httpd',
                'ip': '172.16.78.10',
                'port': [80, 443],
                'fqdn': 'apache-httpd.corp.panw.lan',
                'apache-httpd': {
                    'log_format': log_formats
                }
            }

        def set_internal_dns_bind(
            self,
        ) -> None:
            """ Set the internal bind DNS service.
            """
            self.__internal_dns_bind = {
                'product': 'bind',
                'ip': '172.16.78.2',
                'port': 53,
                'fqdn': 'bind.corp.panw.lan',
                'dns': {
                    'forwarder': '202.12.27.33'
                }
            }

        def set_internal_dhcp_windows(
            self,
        ) -> None:
            """ Set the internal window DHCP service.
            """
            self.__internal_dhcp_windows = {
                'product': 'windows-dhcp',
                'ip': '172.16.77.20',
                'fqdn': 'win-dhcp.corp.panw.lan'
            }

        def set_external_tap(
            self,
            names: list[str],
        ) -> None:
            """ Set the external TAP services.

            :param names: List of product names.
            """
            self.__external_tap = []
            for name in names:
                if service := {
                    'zscaler-nssweb': {
                        'product': 'zscaler-nssweb',
                        'ip': '104.129.192.1'
                    }
                }.get(name):
                    self.__external_tap.append(service)
                else:
                    raise DemistoException(f'Invalid tap product - {name}')

        def set_external_proxy_nssweb(
            self,
        ) -> None:
            """ Set the external zscaler-nssweb proxy service.
            """
            self.__external_proxy_nssweb = {
                'product': 'zscaler-nssweb',
                'ip': '104.129.192.1'
            }

        def build(
            self,
        ) -> ScenarioStruct:
            """ Build a scenario.

            :return: A default scenario.
            """
            scenario = ScenarioStruct()
            scenario.update({'.variables': {}})
            scenario.update({'ip_entries': self.__build_ip_entries()})
            scenario.update(self.__normal_scenario or {})
            scenario.update(self.__irregular_scenario or {})
            scenario.update({
                'services': assign_params(
                    internal=assign_params(
                        gw={
                            'dst_ip': '123.44.5.6'
                        },
                        tap=self.__internal_tap,
                        proxy=self.__internal_proxy_squid,
                        web=self.__internal_web_apache,
                        dns=self.__internal_dns_bind,
                        dhcp=self.__internal_dhcp_windows,
                    ),
                    external=assign_params(
                        tap=self.__external_tap,
                        proxy=self.__external_proxy_nssweb,
                    ),
                )
            })
            return scenario


    class Scenario:
        """ Scenario object
        """
        @staticmethod
        async def __load_struct(
            settings: Settings,
        ) -> ScenarioStruct:
            """ Load scenario

            :param settings: The instance settings.
            :return: The scenario loaded.
            """
            if settings.custom_scenario_enable:
                if not (settings.custom_scenario_url or settings.custom_scenario_json):
                    raise DemistoException('No custom scenarios are configured.')

                scenario = ScenarioStruct()
                if settings.custom_scenario_json:
                    scenario.update(json.loads(settings.custom_scenario_json))

                if settings.custom_scenario_url:
                    async with AsyncHttpClient(
                        base_url=settings.custom_scenario_url,
                        insecure=settings.insecure,
                        proxies=settings.proxies or None,
                        credentials=settings.custom_scenario_url_creds,
                        timeout=settings.socket_timeout,
                        retries=DEFAULT_HTTP_RETRIES,
                    ) as client:
                        content = await client.get_content('')
                        if content[:4] == b'PK\x03\x04':
                            with zipfile.ZipFile(io.BytesIO(content), 'r') as z:
                                z.setpassword((settings.custom_scenario_url_zip_password or '').encode())
                                for fname in sorted([i.filename for i in z.infolist()]):
                                    scenario.update(json.loads(z.read(fname).decode()))
                        else:
                            scenario.update(json.loads(content.decode()))
                return scenario
            else:
                return DefaultScenario.build_default(settings).build()

        @staticmethod
        async def load(
            settings: Settings,
        ) -> ScenarioStruct:
            """ Load scenario

            :param settings: The instance settings.
            :return: The scenario loaded.
            """
            return Scenario(settings, await Scenario.__load_struct(settings))

        def __init__(
            self,
            settings: Settings,
            scenario: ScenarioStruct,
        ) -> None:
            """ Initialize the scenario.

            :param settings: The instance settings.
            :param scenario: The scenario.
            """
            self.__settings = settings
            self.__ip_ents = IpEntries(scenario.ip_entries)
            self.__variables = Variables(None, scenario.variables)
            self.__variables.update_local_vars({'__ips': self.__ip_ents.entries})
            self.__variables.update_local_vars({'__users': self.__ip_ents.build_users()})

            self.__sources = [SourceTemplateUnit(tunit) for tunit in scenario.sources]
            self.__jobs = [JobUnit(junit, self.__variables) for junit in scenario.jobs]
            self.__services = ServiceMap(settings, scenario.services)

        @property
        def variables(
            self
        ) -> Variables:
            return self.__variables

        @property
        def sources(
            self
        ) -> list[SourceTemplateUnit]:
            return self.__sources

        @property
        def jobs(
            self
        ) -> list[JobUnit]:
            return self.__jobs

        @property
        def services(
            self
        ) -> ServiceMap:
            return self.__services

        @property
        def ip_entries(
            self
        ) -> IpEntries:
            return self.__ip_ents


    ''' Player CLASSES '''


    class Player(object):
        """ Player
        """
        __metaclass__ = ABCMeta

        @abstractmethod
        def run(
            self,
            mode: str,
            nrepeat: int | None
        ) -> None:
            """ Run the process to generate and send logs

            :param mode: The run mode. 'random' or 'sequential'
            :param nrepeat: How many times to run the scenario. None = endless.
            """
            pass


    class SourceTemplateUnitsPlayer(Player):
        """ Source Template Units Player
        """
        class ProxyProps:
            """ This class manages both of behind proxy properties and outsice proxy properties.
            """
            def __init__(
                self,
                proxy: ServiceEntity,
                original: dict[str, Any],
                behind: dict[str, Any],
                outside: dict[str, Any],
            ) -> None:
                self.__proxy = proxy
                self.__original = original
                self.__behind = behind
                self.__outside = outside

            @property
            def proxy(
                self,
            ) -> ServiceEntity:
                return self.__proxy

            @property
            def original(
                self,
            ) -> dict[str, Any]:
                return self.__original

            @property
            def behind(
                self,
            ) -> dict[str, Any]:
                return self.__behind

            @property
            def outside(
                self,
            ) -> dict[str, Any]:
                return self.__outside

        class SegmentEntries:
            """ This class manages entries in a network segment.
            """
            def __init__(
                self,
                proxy: list[ProxyServiceEntity],
                dns: list[ServiceEntity],
                tap: list[ServiceEntity],
                gw_src_ip: str | None,
            ) -> None:
                self.__proxy = proxy
                self.__dns = dns
                self.__tap = tap
                self.__gw_src_ip = gw_src_ip

            @property
            def proxy(
                self,
            ) -> list[ProxyServiceEntity]:
                return self.__proxy

            @property
            def dns(
                self,
            ) -> list[ServiceEntity]:
                return self.__dns

            @property
            def tap(
                self,
            ) -> list[ServiceEntity]:
                return self.__tap

            @property
            def gw_src_ip(
                self,
            ) -> str | None:
                return self.__gw_src_ip

        @staticmethod
        def __match_ip_networks(
            ip_netwroks: list[ipaddress.IPv4Network | str],
            ip: str
        ) -> bool:
            """ Check if the IP address given is in the list of IP netwroks.

            :param ip_netwroks: List of IP networks.
            :param ip: An IP address to check.
            :return: Set True if it's in the list of IP networks, otherwise False.
            """
            ip = ipaddress.IPv4Address(ip)
            for ip_network in ip_netwroks:
                if isinstance(ip_network, str):
                    if SourceTemplateUnitsPlayer.__match_ip_networks(
                        [ipaddress.IPv4Network(x, False) for x in argToList(ip_network)],
                        ip
                    ):
                        return True
                elif ip in ip_network:
                    return True

            return False

        @staticmethod
        def __match_ports(
            ports: list[int | str],
            port: int | str
        ) -> bool:
            """ Check if the port number given is in the list of port numbers.

            :param ports: List of port numbers.
            :param port: A port number to check.
            :return: Set True if it's in the list of port numbers, otherwise False.
            """
            port = int(port)
            for p in ports:
                if isinstance(p, str):
                    if SourceTemplateUnitsPlayer.__match_ports(
                        [int(x) for x in toList(p)],
                        port
                    ):
                        return True
                elif port == p:
                    return True
            return False

        @staticmethod
        def __build_proxies_properties(
            proxies: list[ProxyServiceEntity],
            props: dict[str, Any],
        ) -> list[ProxyProps]:
            """ Create log properties for each proxy and behind the proxies.

            :param proxies: List of proxy service entries
            :param props: The log properties for the environment where proxies are not deployed.
            :return: List of log properties for a session via proxy.
            """
            proxy_props = []
            for proxy in proxies:
                if (
                    props.get('app_protocol') in argToList(proxy.protocol or 'http, https')
                    and
                    (
                        not proxy.rules_src or
                        SourceTemplateUnitsPlayer.__match_ip_networks(
                            proxy.rules_src, props.get('src_ip')
                        )
                    )
                    and
                    (
                        not proxy.rules_dst or
                        SourceTemplateUnitsPlayer.__match_ip_networks(
                            proxy.rules_dst, props.get('dst_ip')
                        )
                    )
                    and
                    not SourceTemplateUnitsPlayer.__match_ip_networks(
                        proxy.exceptions_src, props.get('src_ip')
                    )
                    and
                    not SourceTemplateUnitsPlayer.__match_ip_networks(
                        proxy.exceptions_dst, props.get('dst_ip')
                    )
                ):
                    outside_props = dict(props)
                    outside_props.pop('src_user', None)
                    outside_props.pop('dst_user', None)

                    for proxy_port in proxy.ports or [8080]:
                        proxy_props.append(
                            SourceTemplateUnitsPlayer.ProxyProps(
                                proxy=proxy,
                                original=props,
                                behind=dict(
                                    props,
                                    dst_ip=proxy.ip,
                                    dst_port=proxy_port
                                ),
                                outside=dict(
                                    outside_props,
                                    src_ip=proxy.ip,
                                    src_port=random.randint(10000, 65534),
                                ),
                            )
                        )

            return proxy_props

        @staticmethod
        def __build_direct_connection(
            incoming: dict[str, Any],
            outgoing: dict[str, Any],
        ) -> dict[str, Any]:
            """ Replace destination parameters in 'incoming' with 'outgoing' ones.

            :param incoming: The log properties of an incoming session.
            :param outgoing: The log properties of an outgoing session.
            :return Log properties that destination parameters are replaced with the outgoing ones.
            """
            props = dict(incoming)
            for k in ['dst_ip', 'dst_port', 'dst_user']:
                if v := outgoing.get(k):
                    props[k] = v
                else:
                    props.pop(k, None)
            return props

        def __init__(
            self,
            settings: Settings,
            sources: list[SourceTemplateUnit],
            props_generator: LogPropertiesGenerator,
            log_sender: LogSender,
            services: ServiceMap,
            variables: Variables,
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            :param sources: List of source template units to play.
            :param props_generator: The log properties generator.
            :param log_sender: The log sender.
            :param services: The service map.
            :param variables: The variables.
            """
            self.__settings = settings
            self.__props_generator = props_generator
            self.__log_sender = log_sender
            self.__sources = sources
            self.__services = services
            self.__variables = variables

        def __new(
            self,
            sources: list[SourceTemplateUnit],
            variables: Variables,
        ) -> Self:
            """ Create a new instance with the new template sources and variables.

            :param sources: The new source template units for sources.
            :param variables: The new variables.
            :return A new instance. (SourceTemplateUnitsPlayer class)
            """
            p = copy.copy(self)
            p.__sources = sources
            p.__variables = variables
            return p

        async def __generate_and_send_log(
            self,
            generators: list[LogGenerator],
            props: dict[str, Any],
        ) -> None:
            """ Generate and send a log message

            :param generators: List of log generators.
            :param props: Source properties to generate logs.
            """
            for generator in generators:
                try:
                    log_encoder = generator.generate(props)
                except Exception as e:
                    demisto.error(f'Failed to generate log parameters - {e}')
                    IntegrationContextUtils.update_status({
                        'message': f'{e}\n\n{traceback.format_exc()}',
                        'status': IntegrationContextUtils.Status.ERROR,
                    }, sync=True)
                    continue

                if log_encoder:
                    await self.__log_sender.send_log(log_encoder)

        async def __process_dns_query(
            self,
            dns: list[DnsServiceEntity],
            forwarders: list[DnsServiceEntity],
            tap: list[ServiceEntity],
            props: dict[str, Any],
        ) -> None:
            """ Process DNS traffic and logs for a session.

            :param dns: The DNS service entities.
            :param forwarders: The default DNS service entities.
            :param tap: The TAP service entities.
            :param props: Properties of a session.
            """
            app_protocol = props.get('app_protocol')
            fqdn = None
            if app_protocol in ('http, https'):
                fqdn = urllib.parse.urlparse(props.get('http.url') or '').netloc
            elif app_protocol == 'dns':
                fqdn = props.get('dns.query_name')

            if not fqdn:
                return

            for dns_service in dns:
                forwarder_src_port = random.randint(10000, 65534)

                for dns_port in dns_service.ports or [53]:
                    dns_props = {
                        'src_ip': props.get('src_ip'),
                        'src_port': props.get('src_port'),
                        'src_user': props.get('src_user'),
                        'dst_ip': dns_service.ip,
                        'dst_port': dns_port or 53,
                        'dns.query_class': 'IN',
                        'dns.query_type': 'A',
                        'dns.query_name': fqdn,
                        'ip_protocol': 'udp',
                        'app_protocol': 'dns',
                        'fw_action': 'allow',
                    }
                    # DNS logs
                    await self.__generate_and_send_log(dns_service.generators, dns_props)

                    # DNS traffic: Client -> DNS
                    for tap_service in tap:
                        await self.__generate_and_send_log(tap_service.generators, dns_props)

                    # DNS -> DNS Forwarders
                    if (
                        ( forwarders or dns_service.forwarders ) and
                        (
                            not dns_service.domain or
                            not fqdn.lower().endswith('.' + dns_service.domain.lower())
                        )
                    ):
                        if dns_service.forwarders:
                            # DNS traffic: DNS -> DNS Forwarders
                            for dst_ip, dst_port in dns_service.forwarders:
                                dns_props.update({
                                    'src_ip': dns_service.ip,
                                    'src_port': forwarder_src_port,
                                    'dst_ip': dst_ip,
                                    'dst_port': dst_port or 53,
                                })
                                for tap_service in tap:
                                    await self.__generate_and_send_log(tap_service.generators, dns_props)
                        elif forwarders:
                            # DNS traffic: DNS -> DNS Forwarders
                            # DNS Log: Forwarder
                            for forwarder in forwarders:
                                for dst_port in forwarder.ports or [53]:
                                    dns_props.update({
                                        'src_ip': dns_service.ip,
                                        'src_port': forwarder_src_port,
                                        'dst_ip': forwarder.ip,
                                        'dst_port': dst_port or 53,
                                    })

                                for tap_service in tap:
                                    await self.__generate_and_send_log(tap_service.generators, dns_props)

                                await self.__generate_and_send_log(forwarder.generators, dns_props)

        async def __process_outbound_session(
            self,
            props: dict[str, Any],
            route: list[SegmentEntries],
        ) -> list[ProxyProps]:
            """ Process an outbound session through the routes.

            :param props: Properties of a session.
            :param route: Network Route.
            :return: List of log properties for a session via the next proxy.
            """
            if not route:
                return []

            entries = route[0]
            route = route[1:]

            if entries.gw_src_ip:
                props = dict(
                    props,
                    src_ip=entries.gw_src_ip,
                    src_port=random.randint(10000, 65534)
                )

            if xprops := self.__build_proxies_properties(entries.proxy, props):
                # Sessions via proxy
                for pxprops in xprops:
                    # Process the next route
                    if next_proxies := await self.__process_outbound_session(
                        pxprops.outside, route
                    ):
                        for next_pxprops in next_proxies:
                            # DNS log: Proxy -> Next Proxy
                            await self.__process_dns_query(
                                dns=entries.dns,
                                forwarders=next(map(lambda s:s.dns, route), []),
                                tap=entries.tap,
                                props=next_pxprops.behind
                            )
                            # FW log: Proxy -> Next Proxy
                            for service in entries.tap:
                                await self.__generate_and_send_log(
                                    service.generators,
                                    next_pxprops.behind
                                )
                            # Proxy log
                            await self.__generate_and_send_log(
                                pxprops.proxy.generators,
                                self.__build_direct_connection(
                                    pxprops.original,
                                    next_pxprops.behind
                                )
                            )
                    else:
                        # DNS log: Proxy -> External
                        await self.__process_dns_query(
                            dns=entries.dns,
                            forwarders=next(map(lambda s:s.dns, route), []),
                            tap=entries.tap,
                            props=pxprops.outside
                        )
                        # FW log: Proxy -> External
                        for service in entries.tap:
                            await self.__generate_and_send_log(service.generators, pxprops.outside)

                        # Proxy log
                        await self.__generate_and_send_log(pxprops.proxy.generators, pxprops.original)

                    # FW log: Client -> Proxy
                    for service in entries.tap:
                        await self.__generate_and_send_log(service.generators, pxprops.behind)

                return xprops
            elif next_proxies := await self.__process_outbound_session(props, route):
                for next_pxprops in next_proxies:
                    # DNS log: Client -> Next Proxy
                    await self.__process_dns_query(
                        dns=entries.dns,
                        forwarders=next(map(lambda s:s.dns, route), []),
                        tap=entries.tap,
                        props=next_pxprops.behind
                    )
                    # FW log: Client -> Next Proxy
                    for service in entries.tap:
                        await self.__generate_and_send_log(
                            service.generators,
                            next_pxprops.behind
                        )
                return []
            else:
                # DNS log: Client -> External
                await self.__process_dns_query(
                    dns=entries.dns,
                    forwarders=next(map(lambda s:s.dns, route), []),
                    tap=entries.tap,
                    props=props
                )
                # FW log: Client -> External
                for service in entries.tap:
                    await self.__generate_and_send_log(service.generators, props)

                return []

        async def __play_internal_outbound(
            self,
            template: dict[str, Any],
        ) -> None:
            """ Process for 'internal.outbound'

            :param template: The template parameters.
            """
            if not (props := await self.__props_generator.generate(template)):
                return

            route = [
                self.SegmentEntries(
                    proxy=self.__services.internal_proxy,
                    dns=self.__services.internal_dns,
                    tap=self.__services.internal_tap,
                    gw_src_ip=None,
                ),
                self.SegmentEntries(
                    proxy=self.__services.external_proxy,
                    dns=self.__services.external_dns,
                    tap=self.__services.external_tap,
                    gw_src_ip=self.__services.internal_gw_dst_ip,
                )
            ]
            await self.__process_outbound_session(props, route)

            # Access to internal web servers
            for service in self.__services.internal_web:
                if (
                    service.ip == props.get('dst_ip') and
                    self.__match_ports(service.ports or [80, 443], props.get('dst_port'))
                ):
                    await self.__generate_and_send_log(service.generators, props)

        async def __play_template(
            self,
            template: Template,
        ) -> None:
            """ Process for a template

            :param template: The template object.
            """
            match template.template.get('operation'):
                case 'internal.outbound':
                    match template.template.get('type'):
                        case 'network':
                            await self.__play_internal_outbound(template.template)

                        case _:
                            pass

                case operation if operation in ('internal.log', 'log'):
                    match template.template.get('type'):
                        case 'dhcp':
                            if operation == 'internal.log':
                                if props := await self.__props_generator.generate(template.template):
                                    for service in self.__services.internal_dhcp:
                                        await self.__generate_and_send_log(service.generators, props)

                        case 'ngfw-threat':
                            if props := await self.__props_generator.generate(template.template):
                                await self.__generate_and_send_log(
                                    [NGFWLogGenerator(self.__settings, 'threat')],
                                    props
                                )

                        case 'windows-event-ad':
                            if props := await self.__props_generator.generate(template.template):
                                await self.__generate_and_send_log(
                                    [WindowsEventLogGenerator(self.__settings, 'ad')],
                                    props
                                )

                        case 'custom':
                            if props := await self.__props_generator.generate(template.template):
                                await self.__generate_and_send_log(
                                    [CustomLogGenerator(self.__settings)],
                                    props
                                )

                        case _:
                            pass

                case _:
                    pass

            if _wait := template.template.get('.wait'):
                await asyncio.sleep(
                    (max(int(template.variables.eval_str(_wait)), 0))
                )
            if _next := template.template.get('.next'):
                await self.__new(
                    [SourceTemplateUnit(tunit) for tunit in toList(demisto.get(_next, 'sources'))],
                    template.variables,
                ).run(
                    _next.get('mode') or 'sequential', 1
                )

        async def run(
            self,
            mode: str,
            nrepeat: int | None,
        ) -> None:
            """ Run the process to generate and send logs

            :param mode: The run mode. 'random' or 'sequential'
            :param nrepeat: How many times to run the scenario. None = endless.
            """
            if not self.__sources:
                return

            match mode:
                case 'random':
                    def __batch_counters(
                        nrepeat: int | None,
                        nunits: int,
                    ) -> Iterator[int]:
                        it = iter(itertools.count() if nrepeat is None else range(max(nrepeat, 0)))
                        while count := sum(1 for _ in itertools.islice(it, nunits)):
                            yield count

                    weights = [
                        max(0, sum(float(st.get('.weights') or 1) for st in tunit.enum_source_templates()))
                        for tunit in self.__sources
                    ]
                    MAX_BATCH_UNITS = 100000
                    for count in __batch_counters(nrepeat, MAX_BATCH_UNITS):
                        for tunit in random.choices(self.__sources, weights, k=count):
                            for template in tunit.enum_templates(self.__variables):
                                await self.__play_template(template)
                        if template is None:
                            # No templates
                            break

                case 'sequential':
                    template = None
                    for _ in itertools.count() if nrepeat is None else range(max(nrepeat, 0)):
                        for tunit in self.__sources:
                            for template in tunit.enum_templates(self.__variables):
                                await self.__play_template(template)
                        if template is None:
                            # No templates
                            break

                case _:
                    raise DemistoException(f'Invalid run mode - {mode}')

            await self.__log_sender.flush()


    class JobsPlayer(Player):
        @staticmethod
        def update_status(
            job_type: str,
            waiting_jobs: dict[JobUnit, float] | None,
            running_jobs: dict[JobUnit, float] | None,
            last_finished: dict[JobUnit, float] | None,
            sync: bool,
        ) -> None:
            """ Update Job Status

            :param job_type: The job type name.
            :param waiting_jobs: Waiting Jobs
            :param running_jobs: Running Jobs
            :param last_finished: Finished Jobs
            :param sync: Set True to immediately synchronize with the DB, otherwise False.
            """
            IntegrationContextUtils.update_status({
                'jobs': {
                    job_status: [
                        {
                            time_name: timestamp,
                            'label': job.label,
                            'type': job_type,
                        } for job, timestamp in jobs.items()
                    ]
                    for job_status, jobs, time_name in [
                        ('waiting', waiting_jobs, 'next_time'),
                        ('running', running_jobs, 'start_time'),
                        ('finished', last_finished, 'end_time'),
                    ] if jobs is not None
                }
            }, sync=sync)

        """ Jobs Player
        """
        def __init__(
            self,
            settings: Settings,
            jobs: list[JobUnit],
            props_generator: LogPropertiesGenerator,
            log_sender: LogSender,
            services: ServiceMap,
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            :param jobs: List of job units to play.
            :param props_generator: The log properties generator.
            :param log_sender: The log sender.
            :param services: The service map.
            """
            self.__settings = settings
            self.__props_generator = props_generator
            self.__log_sender = log_sender
            self.__jobs = jobs
            self.__services = services
            self.__first_trigger_times: dict[str, float] = {}

        def set_first_trigger_times(
            self,
            first_trigger_times: dict[str, float],
        ) -> None:
            """ Set the first trigger time for the sheduled jobs.

            :param first_trigger_times: The job label with the first time to trigger.
            """
            self.__first_trigger_times = first_trigger_times

        async def run(
            self,
            mode: str,
            nrepeat: int | None,
        ) -> None:
            """ Run the process to generate and send logs

            :param mode: The run mode. 'random' or 'sequential'
            :param nrepeat: How many times to run the scenario. None = endless.
            """
            class ScheduledJobs:
                """ Scheduled Jobs
                """
                class ScheduledJob:
                    """ Scheduled Job
                    """
                    def __init__(
                        self,
                        job: JobUnit,
                        create_player: Callable[[JobUnit], SourceTemplateUnitsPlayer],
                        report_running: Callable[[Self], None],
                        report_scheduled: Callable[[Self], None],
                        first_trigger_time: float = None,
                    ) -> None:
                        self.__job = job
                        self.__create_player = create_player
                        self.__report_running = report_running
                        self.__report_scheduled = report_scheduled
                        if first_trigger_time is None:
                            self.__next_time = job.next_time(utc_timestamp())
                        else:
                            self.__next_time = first_trigger_time

                    @property
                    def next_time(
                        self,
                    ) -> float:
                        return self.__next_time

                    @property
                    def job(
                        self,
                    ) -> JobUnit:
                        return self.__job

                    async def run(
                        self
                    ) -> None:
                        now = utc_timestamp()
                        while self.__report_scheduled(self):
                            # Wait until the next run time
                            # (Allow sleep(0) for the context switch)
                            if self.__next_time >= now:
                                await asyncio.sleep(self.__next_time - now)

                            # Run the job
                            player = self.__create_player(self.__job)
                            self.__report_running(self)
                            await player.run('sequential', 1)

                            now = utc_timestamp()
                            self.__next_time = self.__job.next_time(now)

                def __init__(
                    self,
                    settings: Settings,
                    nrepeat: int,
                    props_generator: LogPropertiesGenerator,
                    log_sender: LogSender,
                    services: ServiceMap,
                ) -> None:
                    self.__settings = settings
                    self.__props_generator = props_generator
                    self.__log_sender = log_sender
                    self.__services = services
                    self.__countdown = itertools.repeat(*([1] if nrepeat is None else [1, nrepeat]))
                    self.__waiting_jobs: map[JobUnit, int] = {}
                    self.__running_jobs: map[JobUnit, int] = {}
                    self.__last_finished: map[JobUnit, int] = {}

                def __enter__(
                    self,
                ) -> Self:
                    return self

                def __exit__(
                    self,
                    exc_type: type[BaseException] | None,
                    exc_val: BaseException | None,
                    traceback: TracebackType | None,
                ) -> None:
                    pass

                def __update_status(
                    self,
                    sync: bool = False,
                ) -> None:
                    JobsPlayer.update_status(
                        job_type='scheduled_job',
                        waiting_jobs=self.__waiting_jobs or None,
                        running_jobs=self.__running_jobs or None,
                        last_finished=self.__last_finished or None,
                        sync=sync,
                    )

                def __create_player(
                    self,
                    job: JobUnit,
                ) -> SourceTemplateUnitsPlayer:
                    return SourceTemplateUnitsPlayer(
                        settings=self.__settings,
                        props_generator=self.__props_generator,
                        log_sender=self.__log_sender,
                        sources=job.sources,
                        services=self.__services,
                        variables=job.variables,
                    )

                def __report_running(
                    self,
                    sche_job: ScheduledJob,
                ) -> None:
                    job = sche_job.job
                    self.__running_jobs[job] = utc_timestamp()
                    self.__waiting_jobs.pop(job, None)
                    self.__update_status()

                def __report_scheduled(
                    self,
                    sche_job: ScheduledJob,
                ) -> bool:
                    if cont := next(self.__countdown, None) is not None:
                        job = sche_job.job
                        self.__waiting_jobs[job] = sche_job.next_time
                        if self.__running_jobs.pop(job, None) is not None:
                            self.__last_finished[job] = utc_timestamp()

                    self.__update_status()
                    return cont

                async def run(
                    self,
                    jobs: list[JobUnit],
                    first_trigger_times: dict[str, float],
                ) -> None:
                    """ Schedule and run jobs

                    :param jobs: The jobs.
                    :param first_trigger_times: The job label with the time to trigger for the first time.
                    """
                    async with asyncio.TaskGroup() as tg:
                        now = utc_timestamp()
                        for job in jobs:
                            tg.create_task(
                                self.ScheduledJob(
                                    job,
                                    create_player=self.__create_player,
                                    report_running=self.__report_running,
                                    report_scheduled=self.__report_scheduled,
                                    first_trigger_time=first_trigger_times.get(job.label),
                                ).run()
                            )


            if not self.__jobs:
                return

            try:
                if mode == 'random':
                    with ScheduledJobs(
                        settings=self.__settings,
                        nrepeat=nrepeat,
                        props_generator=self.__props_generator,
                        log_sender=self.__log_sender,
                        services=self.__services
                    ) as sche_jobs:
                        await sche_jobs.run(self.__jobs, self.__first_trigger_times)

                elif mode == 'sequential':
                    """
                    'sequential' mode in the jobs simply run for each template in order
                    without waiting for its interval timer.
                    """
                    for _ in itertools.count() if nrepeat is None else range(max(nrepeat, 0)):
                        finished_jobs: map[JobUnit, int] = {}
                        for job in self.__jobs:
                            JobsPlayer.update_status(
                                job_type='onetime_job',
                                waiting_jobs=None,
                                running_jobs={job: utc_timestamp()},
                                last_finished=finished_jobs,
                                sync=False,
                            )
                            player = SourceTemplateUnitsPlayer(
                                settings=self.__settings,
                                props_generator=self.__props_generator,
                                log_sender=self.__log_sender,
                                sources=job.sources,
                                services=self.__services,
                                variables=job.variables,
                            )
                            await player.run('sequential', 1)
                            finished_jobs[job] = utc_timestamp()

                        JobsPlayer.update_status(
                            job_type='onetime_job',
                            waiting_jobs=None,
                            running_jobs=None,
                            last_finished=finished_jobs or None,
                            sync=True,
                        )
                else:
                    raise DemistoException(f'Invalid run mode - {mode}')
            except:
                IntegrationContextUtils.remove_status_keys(['jobs'])
                raise


    class ScenarioPlayer:
        """ Scenario Player
        """
        def __init__(
            self,
            settings: Settings,
            scenario: Scenario,
        ) -> None:
            """ Initialize the instance

            :param settings: The instance settings.
            :param scenario: The scenario to play.
            """
            self.__settings = settings
            self.__log_sender = LogSender(settings)
            props_generator = LogPropertiesGenerator(scenario.ip_entries)

            self.__main_player = SourceTemplateUnitsPlayer(
                settings=settings,
                sources=scenario.sources,
                props_generator=props_generator,
                log_sender=self.__log_sender,
                services=scenario.services,
                variables=scenario.variables,
            )
            self.__jobs_player = JobsPlayer(
                settings=settings,
                jobs=scenario.jobs,
                props_generator=props_generator,
                log_sender=self.__log_sender,
                services=scenario.services
            )

        async def __aenter__(
            self,
        ) -> Self:
            return self

        async def __aexit__(
            self,
            exc_type: type[BaseException] | None,
            exc_val: BaseException | None,
            traceback: TracebackType | None,
        ) -> None:
            await self.__log_sender.finish()

        def set_first_trigger_times(
            self,
            first_trigger_times: dict[str, float],
        ) -> None:
            """ Set the first trigger time for the sheduled jobs.

            :param first_trigger_times: The job label with the first time to trigger.
            """
            self.__jobs_player.set_first_trigger_times(first_trigger_times)

        async def run(
            self,
        ) -> None:
            """ Run the process to generate and send logs
            """
            async with asyncio.TaskGroup() as tg:
                task_bgp = tg.create_task(self.__log_sender.run_bg_process())
                task_main = tg.create_task(
                    self.__main_player.run(
                        self.__settings.scenario_run_mode,
                        self.__settings.scenario_sources_loop
                    )
                )
                task_jobs = tg.create_task(
                    self.__jobs_player.run(
                        self.__settings.scenario_run_mode,
                        self.__settings.scenario_jobs_loop
                    )
                )
                await asyncio.wait([task_main, task_jobs], return_when=asyncio.FIRST_EXCEPTION)
                task_bgp.cancel()
                await self.__log_sender.finish()

        async def test(
            self
        ) -> None:
            """ Test connectivity
            """
            await self.__log_sender.test()
            #IntegrationContextUtils.update_status({})
            #await self.run()


    ''' COMMAND FUNCTIONS '''


    def test_module(
        args: dict[str, Any],
        settings: Settings,
    ) -> str:
        """ Validates server settings

        :param args: The argument parameters
        :param settings: The instance settings
        """
        async def __test(
            settings: Settings,
        ) -> None:
            scenario = await Scenario.load(settings)
            async with ScenarioPlayer(settings, scenario) as player:
                await player.test()

        asyncio.run(__test(settings))
        return 'ok'


    def get_running_status_command(
        args: dict[str, Any],
        settings: Settings,
    ) -> CommandResults:
        """ Get the running status information

        :param args: The argument parameters
        :param settings: The instance settings
        """
        status = IntegrationContextUtils.get_status()

        return CommandResults(
            readable_output=build_markdown(
                'Running Status',
                format_status_to_display(status, settings.tz_offset_display),
            ),
            outputs=None if argToBoolean(args.get('show_only', 'true')) else {
                'ScenarioLogPlayer.RunningStatus': status
            },
            raw_response=status
        )


    def get_jobs_status_command(
        args: dict[str, Any],
        settings: Settings,
    ) -> CommandResults:
        """ Get the status information about jobs

        :param args: The argument parameters
        :param settings: The instance settings
        """
        jobs_status = IntegrationContextUtils.get_status().get('jobs')
        if not isinstance(jobs_status, dict):
            readable_output = tblToMd('', {})
        else:
            readable_output = '\n'.join([
                build_markdown(
                    title,
                    sorted(
                        [
                            assign_params(**{
                                'name': job.get('label') or '<NO LABEL>',
                                time_key: format_timestamp_to_display(
                                    job.get(time_key), settings.tz_offset_display
                                )
                            })
                            for job in toList(jobs_status.get(category))
                        ],
                        key=lambda x: x.get(time_key) or '',
                        reverse=order_desc,
                    )
                )
                for category, time_key, title, order_desc in [
                    ('waiting', 'next_time', 'Waiting Jobs', False),
                    ('running', 'start_time', 'Running Jobs', False),
                    ('finished', 'end_time', 'Last Finished', True),
                ]
            ])
        return CommandResults(
            readable_output=readable_output,
            outputs=None if argToBoolean(args.get('show_only', 'true')) else {
                'ScenarioLogPlayer.JobsStatus': jobs_status
            },
            raw_response=jobs_status
        )


    def get_last_run_command(
        args: dict[str, Any],
        settings: Settings,
    ) -> CommandResults:
        """ Get the last run information

        :param args: The argument parameters
        :param settings: The instance settings
        """
        last_run = IntegrationContextUtils.get_last_run()

        return CommandResults(
            readable_output=build_markdown(
                'Last Run',
                format_status_to_display(last_run, settings.tz_offset_display),
            ),
            outputs=None if argToBoolean(args.get('show_only', 'true')) else {
                'ScenarioLogPlayer.LastRun': last_run
            },
            raw_response=last_run
        )


    def get_last_error_command(
        args: dict[str, Any],
        settings: Settings,
    ) -> CommandResults:
        """ Get the last error information

        :param args: The argument parameters
        :param settings: The instance settings
        """
        last_error = IntegrationContextUtils.get_last_error()

        return CommandResults(
            readable_output=build_markdown(
                'Last Error',
                format_status_to_display(last_error, settings.tz_offset_display),
            ),
            outputs=None if argToBoolean(args.get('show_only', 'true')) else {
                'ScenarioLogPlayer.LastError': last_error
            },
            raw_response=last_error
        )


    def get_default_scenario_command(
        args: dict[str, Any],
        settings: Settings,
    ) -> CommandResults:
        """ Get the default scenario template

        :param args: The argument parameters
        :param settings: The instance settings
        """
        scenario = DefaultScenario.build_default(settings).build()
        return fileResult(
            args.get('save_as') or 'default-scenario.json',
            json.dumps(scenario.build(), indent=4)
        )


    def reset_status_command(
        args: dict[str, Any],
        settings: Settings,
    ) -> CommandResults:
        """ Clear all the status information

        :param args: The argument parameters
        :param settings: The instance settings
        """
        IntegrationContextUtils.clear_status()
        return CommandResults(
            readable_output='Done.'
        )


    def var_datetime_command(
        args: dict[str, Any],
        settings: Settings,
    ) -> dict[str, Any]:
        """ Replace date time values with utcnow variables.

        :param args: The argument parameters
        :param settings: The instance settings
        """
        entry_id = args.get('entry_id')

        res = demisto.getFilePath(entry_id)
        with open(res['path'], 'r') as f:
            out = replace_datetime_with_utcnowvar(json.load(f))

        return fileResult(res['name'], json.dumps(out, indent=2))


    async def run_long_running(
        settings: Settings,
    ) -> None:
        """ Start the long running server

        :param settings: The instance settings
        """
        try:
            status = IntegrationContextUtils.get_status()
            if status.get('status') == IntegrationContextUtils.Status.FINISHED:
                demisto.info((
                    'The scenario has already finished.'
                    ' Please reset the status to replay again or play other scenarios.'
                ))
                while status.get('status') == IntegrationContextUtils.Status.FINISHED:
                    time.sleep(5)
                    status = IntegrationContextUtils.get_status()

            # Get waiting + running jobs with the scheduled time in the last run to resume
            first_trigger_times = None
            if (
                settings.scenario_enable_resume_scheduled_jobs and
                settings.scenario_run_mode == 'random'
            ):
                try:
                    if status.get('status') != IntegrationContextUtils.Status.FINISHED:
                        first_trigger_times = {
                            label: float(next_time)
                            for job in toList(demisto.get(status, 'jobs.waiting'))
                            if (
                                job.get('type') == 'scheduled_job' and
                                (label := job.get('label')) and
                                (next_time := job.get('next_time'))
                            )
                        }
                        first_trigger_times.update({
                            label: utc_timestamp()
                            for job in toList(demisto.get(status, 'jobs.running'))
                            if (
                                job.get('type') == 'scheduled_job' and
                                (label := job.get('label'))
                            )
                        })
                except Exception as e:
                    demisto.error(f'Failed to resume scheduled jobs - {e}')
                    pass

            # Start the scenario
            scenario = await Scenario.load(settings)
            IntegrationContextUtils.update_status({
                'started': utc_timestamp(),
                'status': IntegrationContextUtils.Status.RUNNING,
                'instance_name': demisto.integrationInstance(),
            }, new=True, sync=True)

            async with ScenarioPlayer(settings, scenario) as player:
                player.set_first_trigger_times(first_trigger_times or {})
                await player.run()

            # Fall asleep in eternal
            IntegrationContextUtils.update_status({
                'finished': utc_timestamp(),
                'status': IntegrationContextUtils.Status.FINISHED,
                'message': (
                    'The scenario has successfully finished.'
                    ' Resetting the status is required to replay again or play other scenarios.'
                ),
            }, sync=True)
            threading.Event().wait()

        except Exception as e:
            demisto.error(f'An error occurred in long running loop: {e}')
            IntegrationContextUtils.update_status({
                'message': f'{e}\n\n{traceback.format_exc()}',
                'status': IntegrationContextUtils.Status.ERROR,
            }, sync=True)
            raise DemistoException(str(e)) from e


    def main():
        """ Main
        """
        command = demisto.command()
        demisto.debug('Command being called is {}'.format(command))
        commands = {
            'test-module': test_module,
            'slp-get-running-status': get_running_status_command,
            'slp-get-jobs-status': get_jobs_status_command,
            'slp-get-last-run': get_last_run_command,
            'slp-get-last-error': get_last_error_command,
            'slp-get-default-scenario': get_default_scenario_command,
            'slp-reset-status': reset_status_command,
            'slp-var-datetime': var_datetime_command,
        }
        try:
            settings = Settings(demisto.params())
            IntegrationContextUtils.switchCreateAlertMode(
                settings.enable_alert_creation
            )
            match command:
                case 'long-running-execution':
                    asyncio.run(run_long_running(settings=settings))

                case 'fetch-incidents':
                    demisto.setLastRun({})
                    demisto.incidents([])
                    pass

                case _:
                    args = assign_params(**demisto.args())
                    return_results(commands[command](args, settings))
        except Exception as e:
            err_msg = f'Error in {INTEGRATION_NAME} Integration [{e}]\n - {str(traceback.format_exc())}'
            return_error(err_msg)


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

  type: python
  commands:
  - name: slp-get-running-status
    arguments:
    - name: show_only
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      defaultValue: "true"
    outputs:
    - contextPath: ScenarioLogPlayer.RunningStatus
      description: The running status information
    description: Get the running information
  - name: slp-var-datetime
    arguments:
    - name: entry_id
      required: true
      description: The entry ID of a file
  - name: slp-get-last-error
    arguments:
    - name: show_only
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      defaultValue: "true"
    outputs:
    - contextPath: ScenarioLogPlayer.LastError
      description: The last error information
    description: Get the last error information
  - name: slp-get-last-run
    arguments:
    - name: show_only
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      defaultValue: "true"
    outputs:
    - contextPath: ScenarioLogPlayer.LastRun
      description: The last run information
    description: Get the last run information
  - name: slp-get-jobs-status
    arguments:
    - name: show_only
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      defaultValue: "true"
    outputs:
    - contextPath: ScenarioLogPlayer.JobsStatus
      description: The information about running and scheduled jobs
      type: unknown
    description: Get the information about running and scheduled jobs
  - name: slp-reset-status
    arguments: []
    description: Reset all the status information
  - name: slp-get-default-scenario
    arguments:
    - name: save_as
      description: The name to give the file to save
      defaultValue: default-scenario.json
    description: Get the default scenario template
  dockerimage: demisto/py3-tools:1.0.0.116158
  runonce: false
  longRunning: true
  subtype: python3
sourcemoduleid: ExportIndicators
